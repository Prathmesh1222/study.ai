[
  {
    "id": "Unit-2.3 Inheritance_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-2.3 Inheritance.pdf] [PAGE 1] Content 1. Inheritance 2. super Keyword 3. Types of Inheritance 4. Polymorphism [PAGE 2] 1. Inheritance [PAGE 3] Introduction Objectives of the Inheritance: Identify the relationship. \u25cf Represent relationships in a Java program. \u25cf Override methods of the base class. \u25cf Identify the constraints. \u25cf Apply the constraints. \u25cf Using final keywork and Abstract classes. \u25cf [PAGE 4] Introduction Inheritance is the process by which one object acquires the properties of another objects. By use of inheritance an object need to define only qualities that make it unique within class. It can inherit its general attributed from its parent. It provides code re-usability feature. Only single inheritance is allowed among classes. All public and protected members of a super class are accessible in the subclasses. All protected members are also accessible within the package. [PAGE 5] Introduction Relationships are classified as follows: A kind-Of relationship An Is-A relationship A part-Of relationship A Has-A relationship For example: Automobile, Ford, Truck, Car, and Engine. A truck is a kind of an automobile. A car is a kind of an automobile. An engine is a part of an automobile. An automobile has an engine.",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-2.3 Inheritance_1",
    "text": "The Ford is a car. [PAGE 6] How to implement? Common Procedure Step-1: Code the Superclass. Step-2: Code the method in the Superclass. Step-3: Code the Subclass. Step-4: Code the method in the Subclass. Step-5: Save the program. Step-6: Compile the program. Step-7: Execute the program. [PAGE 7] How to implement? Example: Superclass \u2013 Applicant Subclass - Candidate public class Applicant { // Declaring data members String applicantID; String applicantName; String applicantAddress; String applicantPosition; // Initializing variables Applicant ( ) // Constructor without parameter { // Initialize the data members of the applicant class. } // Rest of the code } [PAGE 8] How to implement? Code for method in Superclass public class Applicant() { // Code for displaying the details void ( ) // Super class Method displayDetails { // Code for displaying the attributes } // Rest of the code } [PAGE 9] How to implement? Code for candidate as subclass public class Candidate extends Applicant { // Declaring data members String interviewDate; Boolean candidateStatus; // Initializing variables Candidate ( ) // Constructor without parameter { interviewDate = \u201c04 \u2013 June \u2013 2010\u201d ; candidateStatus = false ; } // Rest of the code for candidate class }",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-2.3 Inheritance_2",
    "text": "[PAGE 10] How to implement? Code the method in subclass public class Candidate extends Applicant { void displayDetails ( ) { // Call the displayDetails ( ) method of the superclass. Super . displayDetails ( ); // Code for displaying the attributes of candidate class. } // Initializing variables Candidate ( ) { // Code for initializing the data members } // Rest of the code for candidate class } [PAGE 11] Usage of Inheritance Reduce redundancy in code: Code redundancy means writing the same code in different places, leading to unnecessary replication of code. Inheritance helps us to reuse code. Maintain code easily, as the code resides at one place (superclass). Any change made to the superclass automatically changes the behavior of subclass because the subclasses inherit the new behavior automatically. Extend the functionality of an existing class by adding more methods to the subclass. [PAGE 12] Points to Remember The keyword \u201cextends\u201d is used to inherit a subclass from superclass. A class member that has declared as private will remain private to its class. It is not accessible by any code outside its class, including subclasses. [PAGE 13] 2. super Keyword [PAGE 14] Introduction The super keyword in",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-2.3 Inheritance_3",
    "text": "java is a reference variable that is used to refer immediate parent class object. Whenever you create the instance of subclass, an instance of parent class is created implicitly i.e. referred by super reference variable. Usage of java super Keyword super is used to refer immediate parent class instance variable. super() is used to invoke immediate parent class constructor. super is used to invoke immediate parent class method. [PAGE 15] Introduction Super has two general forms: * The first calls the superclass constructor. * The second is used to access a member of the superclass that has hidden by a member of a subclass. [PAGE 16] Calling Superclass Constructor A subclass can call a constructor method defined by its superclass by use of the following form of super: super(parameter-list); Here, parameter-list specifies any parameters needed by the constructor in the superclass. super( ) must always be the first statement executed inside a subclass\u2019 constructor. [PAGE 17] Calling Superclass Member The second form of super acts somewhat like this keyword, except that it always refers to the superclass of the subclass in which it is used. General form: super.m Here, member can be either a method or instance variable. This second",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-2.3 Inheritance_4",
    "text": "form of super is most applicable to situations in which member names of a subclass hide members by the same name in the superclass. [PAGE 18] JAVA super Keyword class Vehicle{ int speed=50; } class Car extends Vehicle{ int speed=100; +super.speed void display(){ System.out.println(\u201cCar Speed:\u201d+speed); } public static void main(String args[]){ Car c=new Car(); c.display(); CCaarr SSppeeeedd::15000 } } [PAGE 19] JAVA super Keyword contd... Classes use constructors to initialize instance variables When a subclass object is created, its constructor is called. It is the responsibility of the subclass constructor to invoke the appropriate superclass constructors so that the instance variables defined in the superclass are properly initialized. Superclass constructors can be called using the \"super\" keyword in a manner similar to \"this\u201c keyword It must be the first line of code in the constructor. If a call to super is not made, the system will automatically attempt to invoke the no-argument constructor of the superclass. [PAGE 20] JAVA super Keyword contd... // When subclass constructor called. // Create Superclass Vehicle class Vehicle { Vehicle() { System.out.println(\" Vehicle class constructor.\"); }} // Create Car subclass by extending class Vehicle. class Car extends Vehicle { Car() { System.out.println(\"Car class constructor.\"); }}",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-2.3 Inheritance_5",
    "text": "// Create Ford subclass by extending Car. class Ford extends Car { Ford() { System.out.println(\"Ford class constructor.\"); }} class CallingCons { public static void main(String args[]) { Ford f = new Ford(); } } [PAGE 21] 3. Types of Inheritance [PAGE 22] Introduction Single Inheritance: Only one superclass and subclass. Multiple Inheritance: More than one superclass. (Java uses interfaces) Multilevel Inheritance: One superclass and more than one subclasses. Hierarchical Inheritance: Derived from a Derived class only. [PAGE 23] Introduction [PAGE 24] Introduction [PAGE 25] Introduction [PAGE 26] Single Inheritance When a class inherits another class, it is known as a single inheritance. class Animal{ void eat() {System.out.println(\"eating...\");} } class Dog extends Animal{ void bark() {System.out.println(\"barking...\");} } class InheritanceTest{ public static void main(String args[]){ Dog d=new Dog(); d.bark(); // subclass Dog method d.eat(); // superclass Animal method }} [PAGE 27] Multilevel Inheritance When there is a chain of inheritance, it is known as multilevel inheritance. class Animal{ void eat(){System.out.println(\"eating...\");} } class Dog extends Animal{ void bark(){System.out.println(\"barking...\");} } class BabyDog extends Dog{ void weep(){System.out.println(\"weeping...\");} } class InheritanceTest{ public static void main(String args[]){ BabyDog d=new BabyDog(); d.weep(); d.bark(); d.eat(); }} [PAGE 28] Hierarchical Inheritance When two or more classes inherits a single class.",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-2.3 Inheritance_6",
    "text": "class Animal{ void eat(){System.out.println(\"eating...\");} } class Dog extends Animal{ void bark(){System.out.println(\"barking...\");} } class Cat extends Animal{ void meow(){System.out.println(\"meowing...\");} } class InheritanceTest{ public static void main(String args[]){ Cat c=new Cat(); c.meow(); c.eat(); c.bark(); // Compile time error }} [PAGE 29] Multiple Inheritance Java does not support multiple inheritance. Reason: Dangling References. Compile Time Error / Run Time Error Solution: Using interface Interface: Interface is a abstract type that the interface name as like class name. Syntax: <access_specifier> interface <interface_name> Example: public interface Shapes { Circle(); Rectangle(); [PAGE 30] 4. Polymorphism [PAGE 31] Introduction Polymorphism in Java is a concept by which we can perform a single action in different ways. Polymorphism is derived from 2 Greek words: poly and morphs. The word \"poly\" means many and \"morphs\" means forms. So polymorphism means many forms. There are two types of polymorphism in Java: 1. Compile time polymorphism 2. Run time polymorphism. We can perform polymorphism in java by method overloading and method overriding. If you overload a static method in Java, it is the example of compile time polymorphism. [PAGE 32] Compile Time Polymorphism In Java, we can create method that have same name, but different parameter lists and different definitions. This",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-2.3 Inheritance_7",
    "text": "kind of method creation is called Method Overloading. Method Overloading Process: When objects are required to perform similar tasks but using different input parameters. When call a method, Java compiler matches up the method name first and then the number and type of parameters to decide which one of the declarations to execute. [PAGE 33] Compile Time Polymorphism cont... class Room { float length; float breadth; Room(float x, float y) // Constructor-1 { length = x; breadth = y; } Room(float x) // Constructor-2 { length = breadth = x; } int area() { return(length * breadth); } } [PAGE 34] Compile Time Polymorphism cont... An object representing a Rectangular Room will be created by using constructor-1 Room room1 = new Room(25.5, 20.0); An object representing a Square Room will be created by using constructor-2 Room room2 = new Room(25.0); [PAGE 35] Run Time Polymorphism Method Signature = Method_Name + Parameter_List Method Overriding: A method defined in the subclass has the same name signature as like superclass, then the subclass method overrides (hides/supersedes) the definition of the superclass method. C++ and C# languages are using Virtual Functions that are same as overridden method in Java. [PAGE 36] Run Time Polymorphism",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-2.3 Inheritance_8",
    "text": "cont... Rules for Overriding Methods: The method name and the order of arguments should be identical to that of the superclass method. The return type of both the methods must be the same. The overriding method cannot be less accessible than the method it overrides. For example: If the method override is declared as public in the superclass cannot override it with the private keyword in the subclass. An overriding method cannot raise more exceptions than those raised by the method of the superclass (Exception and Errors are raised at runtime). [PAGE 37] Run Time Polymorphism cont... Process of Overriding Methods: class Chair { public void adjustHeight() { System.out.println(\u201cAdjusting Chair Height\u201d); } } public class WheelChair extends Chair { public void adjustHeight() // override { System.out.println(\u201cAdjusting WheelChair Height\u201d); } public static void main(String[] a) { WheelChair wchair = new WheelChair(); wchair.adjustHeight(); // calling method } } [PAGE 38] Run Time Polymorphism cont... Process of Overriding Methods: When we call the method \u201cadjustHeight()\u201d, the compiler searches for the method in the current class (WheelChair) first. If it is not available in the current class then the compiler searches for the method in the superclass.",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.3 Inheritance.txt"
    }
  },
  {
    "id": "Unit-5.1 Database Applications with JDBC_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-5.1 Database Applications with JDBC.pdf] [PAGE 1] CSE 2006 - Programming in Java Course Type: LP Credits: 3 [PAGE 2] Unit- 5 Database Applications With JDBC Defining the layout of the JDBC API - Connecting to a database by using a JDBC driver \u2013 Submitting queries and getting results from the database - Specifying JDBC driver information externally. Java Persistence API JPA architecture, ORM Components, - Performing CRUD operations using the JDBC API. JPA installation, Java Persistence Query language, Creating JPA entities, Advanced mappings. 2 [PAGE 3] Database Applications with JDBC Layout The current version of JDBC is 4.3. It is the stable release since 21st September, 2017. It is based on the X/Open SQL Call Level Interface. The java.sql package contains classes and interfaces for JDBC API. 3 [PAGE 4] Connecting to a database by using a JDBC driver JDBC stands for Java Database Connectivity. JDBC is a Java API to connect and execute the query with the database. It is a part of JavaSE (Java Standard Edition). JDBC API uses JDBC drivers to connect with the database. There are four types of JDBC drivers: 1. JDBC-ODBC Bridge Driver 2. Native Driver 3. Network",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.1 Database Applications with JDBC.txt"
    }
  },
  {
    "id": "Unit-5.1 Database Applications with JDBC_1",
    "text": "Protocol Driver 4. Thin Driver We have discussed the above four drivers in the next chapter. We can use JDBC API to access tabular data stored in any relational database. By the help of JDBC API, we can save, update, delete and fetch data from the database. It is like Open Database Connectivity (ODBC) provided by Microsoft. 4 [PAGE 5] Database Applications with JDBC Why Should We Use JDBC Before JDBC, ODBC API was the database API to connect and execute the query with the database. But, ODBC API uses ODBC driver which is written in C language (i.e. platform dependent and unsecured). That is why Java has defined its own API (JDBC API) that uses JDBC drivers (written in Java language). We can use JDBC API to handle database using Java program and can perform the following activities: 1. Connect to the database 2. Execute queries and update statements to the database 3. Retrieve the result received from the database. 5 [PAGE 6] JDBC connection to Microsoft Access 6 [PAGE 7] JDBC connection to Microsoft Access JDBC connection using JDBC to a Microsoft Access database. This connection is made with the help of a JdbcOdbc driver. You need to",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.1 Database Applications with JDBC.txt"
    }
  },
  {
    "id": "Unit-5.1 Database Applications with JDBC_2",
    "text": "use the following steps for making a connection to the database. Creating a Database Step 1: Open Microsoft Access and select Blank database option and give the database name as File name option 7 [PAGE 8] JDBC connection to Microsoft Access Step 2: Create a table and insert your data into the table 8 [PAGE 9] JDBC connection to Microsoft Access Now Creating DSN of your database Step 3: Open your Control Panel and then select Administrative Tools. Step 4 : Click on Data Source(ODBC)-->System DSN. 9 [PAGE 10] JDBC connection to Microsoft Access Step 5: Now click on add option for making a new DSN.select Microsoft Access Driver (*.mdb. *.accdb) and then click on Finish 10 [PAGE 11] JDBC connection to Microsoft Access Step 6: Make your desired Data Source Name and then click on the Select option, for example in this article we use the name mydsn 11 [PAGE 12] JDBC connection to Microsoft Access Step 7 Now you select your data source file for storing it and then click ok and then click on Create and Finish 12 [PAGE 13] JDBC connection to Microsoft Access Step 8: Java program code import java.sql.*; import sun.jdbc.odbc.*; class exjdbc {",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.1 Database Applications with JDBC.txt"
    }
  },
  {
    "id": "Unit-5.1 Database Applications with JDBC_3",
    "text": "String name; String rollno,m1,m2; void listDetails() throws SQLException { try { Class.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\"); } catch(ClassNotFoundException e) { }; Connection con=DriverManager.getConnection(\"jdbc:odbc:gk\"); Statement st=con.createStatement(); String str=\"INSERT INTO STUD VALUES('\"+name+\"','\"+rollno+\"',\"+m1+\",\"+m2+\");\"; ResultSet rs=st.executeQuery(\"SELECT * FROM gk\"); System.out.println(\" NAME ROLLNO M1 M2 \"); System.out.println(\"--------------------------\"); while(rs.next()) { name=rs.getString(1); rollno=rs.getString(2); m1=rs.getString(3); m2=rs.getString(4); System.out.println(name+\"\\t\"+rollno+\"\\t\"+m1+\"\\t\"+m2); } } 13 [PAGE 14] JDBC connection to Microsoft Access public static void main(String a[]) { exjdbc e1=new exjdbc(); try { e1.listDetails(); } catch(SQLException e2) { System.out.println(e2); } } } 14 [PAGE 15] JDBC Driver JDBC Driver is a software component that enables java application to interact with the database. There are 4 types of JDBC drivers: 1. JDBC-ODBC bridge driver 2. Native-API driver (partially java driver) 3. Network Protocol driver (fully java driver) 4. Thin driver (fully java driver) 15 [PAGE 16] JDBC Driver 1) JDBC-ODBC bridge driver The JDBC-ODBC bridge driver uses ODBC driver to connect to the database. The JDBC-ODBC bridge driver converts JDBC method calls into the ODBC function calls. This is now discouraged because of thin driver. 16 [PAGE 17] JDBC Driver Oracle does not support the JDBC-ODBC Bridge from Java 8. Oracle recommends that you use JDBC drivers provided by the vendor of your database instead of the JDBC-ODBC",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.1 Database Applications with JDBC.txt"
    }
  },
  {
    "id": "Unit-5.1 Database Applications with JDBC_4",
    "text": "Bridge. Advantages: Easy to use. can be easily connected to any database. Disadvantages: Performance degraded because JDBC method call is converted into the ODBC function calls. The ODBC driver needs to be installed on the client machine. 17 [PAGE 18] JDBC Driver 2) Native-API driver The Native API driver uses the client-side libraries of the database. The driver converts JDBC method calls into native calls of the database API. It is not written entirely in java. 18 [PAGE 19] JDBC Driver 2) Native-API driver Advantage: performance upgraded than JDBC-ODBC bridge driver. Disadvantage: The Native driver needs to be installed on the each client machine. The Vendor client library needs to be installed on client machine. 19 [PAGE 20] JDBC Driver 3) Network Protocol driver The Network Protocol driver uses middleware (application server) that converts JDBC calls directly or indirectly into the vendor-specific database protocol. It is fully written in java. 20 [PAGE 21] JDBC Driver 3) Network Protocol driver Advantage: No client side library is required because of application server that can perform many tasks like auditing, load balancing, logging etc. Disadvantages: Network support is required on client machine. Requires database-specific coding to be done in the middle tier. Maintenance",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.1 Database Applications with JDBC.txt"
    }
  },
  {
    "id": "Unit-5.1 Database Applications with JDBC_5",
    "text": "of Network Protocol driver becomes costly because it requires database-specific coding to be done in the middle tier. 21 [PAGE 22] JDBC Driver 4) Thin driver The thin driver converts JDBC calls directly into the vendor-specific database protocol. That is why it is known as thin driver. It is fully written in Java language. 22 [PAGE 23] JDBC Driver 4) Thin driver The thin driver converts JDBC calls directly into the vendor-specific database protocol. That is why it is known as thin driver. It is fully written in Java language. Advantage: Better performance than all other drivers. No software is required at client side or server side. Disadvantage: Drivers depend on the Database. 23 [PAGE 24] More on JDBC More on JDBC https://www.javatpoint.com/java-jdbc MS access with JDBC connection https://www.c-sharpcorner.com/UploadFile/433c33/jdbc-con nection-to-ms-access/ Performing CRUD operations using the JDBC API https://www.javaguides.net/2020/02/java-jdbc-crud-operatio ns-in-eclipse.html 24",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.1 Database Applications with JDBC.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-2.4 Special Classes.pdf] [PAGE 1] Content 1. Nested and Inner class 2. Static class 3. Singleton class 4. Anonymous class 5. Enum class, constructor, String. 6. Reflection [PAGE 2] 1. Nested and Inner Class [PAGE 3] Introduction Java inner class or nested class is a class that is declared inside the class or interface. We use inner classes to logically group classes and interfaces in one place to be more readable and maintainable. Additionally, it can access all the members of the outer class, including private data members and methods. Syntax of Inner class class Java_Outer_class{ //code class Java_Inner_class{ //code } } [PAGE 4] Introduction cont... There are three advantages of inner classes in Java. 1. Nested classes represent a particular type of relationship that is it can access all the members (data members and methods) of the outer class, including private. 2. Nested classes are used to develop more readable and maintainable code because it logically group classes and interfaces in one place only. 3. Code Optimization: It requires less code to write. [PAGE 5] Introduction cont... When we use? A programmer decide that no other class can access a class, then include it",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_1",
    "text": "within other classes. If all the class objects are a part of the outer object then it is easier to nest that class inside the outer class. That way all the outer class can access all the objects of the inner class. How to differentiate Nested and Inner class? An inner class is a part of a Nested class. Non static Nested classes are Inner class. [PAGE 6] Types of Nested Class There are two types of nested classes 1. Static Nested class: A static class within a class. Nested Interface: Within a class or interface. 2. Non-static Nested class. (Inner class) Local Inner class: Within the method. Member Inner class: Within a class & Outside of method. Anonymous Inner class: Extending class or implementing interface. [PAGE 7] How to implement? A non-static class that is created inside a class but outside of a method is called \u201cmember inner class\u201d or \u201cregular inner class\u201d. Access Modifiers: public, private, protected, default. Syntax: class MatrixArithmaticOperations { // Code class MatrixAddition { // Code } } [PAGE 8] How to implement? cont... class OuterTest // Outer class { private int x = 100; class InnerTest // Inner class { void display() { System.out.println(\u201cOuter",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_2",
    "text": "member=\u201d +x); } } // End of Inner class public static void main(String[] args) { OuterTest ot = new OuterTest(); OuterTest.InnerTest it = ot.new InnerTest(); it.display(); } } // End of Outer class [PAGE 9] 2. Static Class [PAGE 10] Introduction A static class is a class that is created inside a class, is called a static nested class in Java. It cannot access non-static data members and methods. It can be accessed by outer class name. It can access static data members of the outer class, including private. The static nested class cannot access non-static (instance) data members. class TestOuter1{ static int data=30; static class Inner{ void msg(){System.out.println(\"data is \"+data);} } public static void main(String args[]){ TestOuter1.Inner obj=new TestOuter1.Inner(); obj.msg(); } } [PAGE 11] How we use? When a class needed to initialize instance methods. In our example, the class TestOuter need to initialize instance method \u201cmsg()\u201d. Therefore we need to create the instance of static nested class. Here, we don't need to create the object of the Outer class because the nested class is static and static properties, methods, or classes can be accessed without an object. [PAGE 12] 3. Singleton Class [PAGE 13] Introduction In Java, Singleton",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_3",
    "text": "is a design pattern that ensures that a class can only have one object. To create a singleton class, a class must implement the following properties: Create a private constructor of the class to restrict object creation outside of the class. Create a private attribute of the class type that refers to the single object. Create a public static method that allows us to create and access the object we created. Inside the method, we will create a condition that restricts us from creating more than one object. [PAGE 14] Introduction Singletons class have only one object (an instance of the class) at a time. One more time we instantiate the Singleton classes, the new variable also points to the first instance created. So, whatever modifications we do to any variable inside the class through any instance, affects the variable of the single instance created and is visible if we access that variable through any variable of that class type defined. 1. Make a constructor private. 2. Write a static method that has the return type object of this singleton class. (Lazy Initialization) [PAGE 15] Design There are two forms of design pattern: 1. Early Instantiation \u2013 The object creation",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_4",
    "text": "takes place at the load time. 2. Lazy Instantiation \u2013 The object is done according to the requirement. Ensure that only one instance of the class exists. Provide global access to that instance by: * Declaring all constructor of the class to be private. * Providing a static method that returns a reference to the instance. * The instance is stored as a private static variable. Example of singleton classes are: Runtime class, Action Servlet, Service Locator, Private Constructor, Factory Methods, etc. [PAGE 16] Implementation class SingletonExample { // private field that refers to the object private static SingletonExample singleObject; private SingletonExample() { // constructor of the SingletonExample class } public static SingletonExample getInstance() { // write code that allows us to create only one object // access the object as per our need } } private static SingletonExample singleObject - a reference to the object of the class. private SingletonExample() - a private constructor that restricts creating objects outside of the class. public static SingletonExample getInstance() - this method returns the reference to the only object of the class. Since the method static, it can be accessed using the class name. [PAGE 17] Purpose The primary purpose is to",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_5",
    "text": "restrict the limit of the number of object creation is only one. Ex: Access Control to resources \u2013 socket or Database connection. Memory space wastage does not occur because of restricted instance creation. The object creation will take place only once instead of creating it each time a new request is made. We can use the singleton object repeatedly as per the requirements. Ex: In multi-threaded and Database applications \u2013 caching, logging, thread pooling, configuration settings, etc. (JDBC driver does not support multi-threading) [PAGE 18] Implementation class Database { private static Database dbObject; private Database() { } public static Database getInstance() { // create object if it's not already created if(dbObject == null) { dbObject = new Database(); } // returns the singleton object return dbObject; } public void getConnection() { System.out.println(\"You are now connected to the database.\"); } } [PAGE 19] 4. Anonymous Inner Class [PAGE 20] Introduction Java anonymous inner class is an inner class without a name and for which only a single object is created. An anonymous inner class can be useful when making an instance of an object with certain \"extras\" such as overloading methods of a class or interface, without having to actually subclass",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_6",
    "text": "a class. In simple words, a class that has no name is known as an anonymous inner class in Java. It should be used if you have to override a method of class or interface. Java Anonymous inner class can be created in two ways: 1. Class (may be abstract or concrete). 2. Interface [PAGE 21] Implementation using class abstract class Person { abstract void eat(); } class TestAnonymousInner { public static void main(String args[]) { Person p=new Person(){ void eat() {System.out.println(\"nice fruits\");} }; p.eat(); } } [PAGE 22] Implementation using interface interface Eatable { void eat(); } class TestAnnonymousInner1 { public static void main(String args[]){ Eatable e=new Eatable(){ public void eat() {System.out.println(\"nice fruits\");} }; e.eat(); } } [PAGE 23] Local Inner Class A class i.e., created inside a method, is called local inner class in java. Local Inner Classes are the inner classes that are defined inside a block. Generally, this block is a method body. Sometimes this block can be a for loop, or an if clause. Local Inner classes are not a member of any enclosing classes. They belong to the block they are defined within, due to which local inner classes cannot have any access modifiers",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_7",
    "text": "associated with them. However, they can be marked as final or abstract. These classes have access to the fields of the class enclosing it. If you want to invoke the methods of the local inner class, you must instantiate this class inside the method. [PAGE 24] Implementation of Local Inner Class public class LocalInner{ private int data=30; //instance variable void display() { class Local{ void msg() {System.out.println(data);} } // end of Local Local l=new Local(); l.msg(); } // end of display() public static void main(String args[]){ LocalInner obj=new LocalInner(); obj.display(); } // end of main } // end of class LocalInner [PAGE 25] 5. enum class, constructor, string [PAGE 26] Introduction In Java, an enum (short for enumeration) is a type that has a fixed set of constant values. We use the enum keyword to declare enums. enum Size { SMALL, MEDIUM, LARGE, EXTRALARGE } Here, we have created an enum named Size. It contains fixed values SMALL, MEDIUM, LARGE, and EXTRALARGE. These values inside the braces are called enum constants (values). Note: The enum constants are usually represented in uppercase. [PAGE 27] Introduction enum Size { SMALL, MEDIUM, LARGE, EXTRALARGE } class ShirtSize{ public static void main(String[] args) {",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_8",
    "text": "System.out.println(Size.SMALL); System.out.println(Size.MEDIUM); } } [PAGE 28] Constructor In Java, an enum class may include a constructor like a regular class. These enum constructors are either private - accessible within the class or package-private - accessible within the package [PAGE 29] Constructor Implementation enum Size { // enum constants calling the enum constructors SMALL(\"The size is small.\"), MEDIUM(\"The size is medium.\"), LARGE(\"The size is large.\"), EXTRALARGE(\"The size is extra large.\"); private final String pizzaSize; // private enum constructor private Size(String pizzaSize) { this.pizzaSize = pizzaSize; } public String getSize() { return pizzaSize; } } [PAGE 30] Constructor Implementation class Main { public static void main(String[] args) { Size size = Size.SMALL; System.out.println(size.getSize()); } } [PAGE 31] Constructor Implementation Explanation Create an enumerated class Size. Includes a private enum constructor. The constructor takes a string value as a parameter and assigns value to the variable pizzaSize. Since the constructor is private, we cannot access it from outside the class. However, we can use enum constants to call the constructor. In the Main class, we assigned SMALL to an enum variable size. The constant SMALL then calls the constructor Size with string as an argument. Finally, we called getSize() using size variable. [PAGE",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_9",
    "text": "32] String In Java, we can get the string representation of enum constants using the toString() method or the name() method. enum Size { SMALL, MEDIUM, LARGE, EXTRALARGE } class Main { public static void main(String[] args) { System.out.println(\"string value of SMALL is\"+Size.SMALL.toString()); System.out.println(\"string value of MEDIUM is\"+Size.MEDIUM.name()); } } [PAGE 33] 6. Reflection [PAGE 34] Introduction Reflection is an API that is used to examine or modify the behavior of methods, classes, and interfaces at runtime. The required classes for reflection are provided under java.lang.reflect package. [PAGE 35] Introduction Reflection gives us information about the class to which an object belongs and also the methods of that class that can be executed by using the object. Through reflection, we can invoke methods at runtime irrespective of the access specifier used with them. [PAGE 36] Introduction Reflection is the ability of the software to analyze itself at runtime. Reflection is provided by the \u201cjava.lang.reflect\u201d package and elements in class. Reflection mechanism is helpful to tool builders, not application programmers. Reflection Mechanism Usages: * Analyze the capabilities of classes at runtime. * Inspect objects at runtime. * Implement generic array manipulation code. [PAGE 37] Structure of Reflection Java.lang.Class Field[] getFields() Field[]",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_10",
    "text": "getDeclaredFields() Method[] getMethod() Method[] getDeclaredMethods() Constructor[] getConstructor() Constructor[] getDeclaredConstructors() Return all public members of the Return all kind of members (public, class and super class. private, protected) in the class. Java.lang.reflect Field Method Constructor [PAGE 38] Implementation Reflection can be used to get information about class, constructors, and methods. The getClass() method is used to get the name Class of the class to which an object belongs. The getConstructors() method is used to get the Constructors public constructors of the class to which an object belongs. The getMethods() method is used to get the Methods public methods of the class to which an object belongs. [PAGE 39] Implementation cont... In Java, reflection allows us to inspect and manipulate classes, interfaces, constructors, methods, and fields at run time. There is a class in Java named Class that keeps all the information about objects and classes at runtime. The object of Class can be used to perform reflection. [PAGE 40] Implementation cont... Step-1: Create an object of Class. Step-2: Using the object we can call various methods to get information about methods, fields, and constructors present in a class. There exists three ways to create objects of Class: 1. Using forName() method",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_11",
    "text": "class Dog {...} // create object of Class to reflect the Dog class Class a = Class.forName(\"Dog\"); The forName() method takes the name of the class to be reflected as its argument. [PAGE 41] Implementation cont... 2. Using getClass() method // create an object of Dog class Dog d1 = new Dog(); // create an object of Class // to reflect Dog Class b = d1.getClass(); Here, we are using the object of the Dog class to create an object of Class. 3. Using .class extension // create an object of Class to reflect the Dog class Class c = Dog.class; Now that we know how we can create objects of the Class. We can use this object to get information about the corresponding class at runtime. [PAGE 42] Reflection - Field Reflection provide information about fields. The getFields() method returns an array containing Field objects for the public fields. The getDeclaredFields() method returns an array of Field objects for all fields. This method return an array of length 0 if there are no such fields. [PAGE 43] Example - Field public Fields: import java.lang.reflect.*; public int Test.a class Test { public int a; private int b; protected int c;",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_12",
    "text": "int d; All Declared Fields: } public int Test.a public class FieldDemo { private int Test.b public static void main(String a[]) throws Exception { protected int Test.c Class c = Class.forName(\u201cTest\u201d); int Test.d Field f1[] = c.getFields(); Field f2[] = c.getDeclaredFields(); System.out.println(\u201cpublic Fields:\u201d); for(int i=0; i<f1.length; i++) System.out.println(f1[i]); System.out.println(\u201cAll Declared Fields:\u201d); for(i=0; i<f2.length; i++) System.out.println(f2[i]); } } [PAGE 44] Reflection - Method Reflection provide information about method. The getMethods() method returns an array containing Method objects that give all the public methods including parent class. The getDeclaredMethods() method returns all methods of the class or interface. [PAGE 45] Example - Method public Methods of class Test and its super class: add hashcode All Declared Methods: import java.lang.reflect.*; getClass add class Test { wait sub public void add() { } equals private void sub() { } mul notify protected void mul() { } div ntoifyAll void div() { } toString } public class MethodDemo { public static void main(String a[]) throws Exception { Class c = Class.forName(\u201cTest\u201d); Method m1[] = c.getMethods(); Method m2[] = c.getDeclaredMethods(); System.out.println(\u201cpublic Methods of class Test and its super class:\u201d); for(int i=0; i<m1.length; i++) System.out.println(m1[i].getName()); System.out.println(\u201cAll Declared Methods:\u201d); for(i=0; i<m2.length; i++) System.out.println(m2[i].getName()); } } [PAGE 46] Reflection",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-2.4 Special Classes_13",
    "text": "- Constructor Reflection provide information about constructors. The getConstructors() method returns an array containing Constructor objects that give all the public constructors. The getDeclaredConstructors() method returns all constructors of the class represented by the Class object. Run Time Object Analysis f.set(obj, value) sets the field represented by f of the object obj to the new value. f.get(obj) returns an object whose value is the current value of the field of obj. [PAGE 47] Example - Constructor Before a = 10 import java.lang.reflect.*; class Test { public int a, b; After a = 11 Test(int x, int y) { a = x; b = y; } Before b = 20 } public class ConstructorDemo { After b = 25 public static void main(String a[]) throws Exception { Test t = new Test(10, 20); System.out.println(\u201cBefore a = \u201c +t.a); Field f1 = t.getClass().getField(\u201ca\u201d); int c = f1.getInt(t)+1; f1.setInt(t, c); System.out.println(\u201c\\n After a =\u201d +c); System.out.println(\u201cBefore b =\u201d +t.b); Field f2 = t.getClass().getField(\u201cb\u201d); f2.set(t, 25); System.out.println(\u201cAfter b = \u201c +f2.get(t)); } } [PAGE 48] Exercises 1. Reflection invoke Method without Parameter 2. Reflection invoke Method with Parameter 3. Reflection invoke Method by Name",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.4 Special Classes.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-3.2 Java Multithreading.pdf] [PAGE 1] Forms of Parallel Processing Distributed computing: Coarse-grained parallelism with relatively high communication cost (\u201ccluster computing\u201d) Fine-grained parallel processing: Massive parallelism, single-instruction-stream, multiple-data-stream processing. (e.g., for in-camera image processing). MIMD Multiprocessors with separate memories. Parallel Random Access Machines (shared memory) Multithreaded architectures (shared memory) [PAGE 2] Tasks and Threads Thread: \u201ca thread of execution\u201d \u201cSmaller\u201d, \u201clighter\u201d than a process smallest unit of processing that can be scheduled by an operating system Has its own run-time call stack, copies of the CPU\u2019s registers, its own program counter, etc. Process has its own memory address space, but threads share one address space A single program can be multi-threaded Time-slicing done just like in multiprocessing Repeat: The threads share the same memory [PAGE 3] Task A task is an abstraction of a series of steps. . Might be done in a separate thread In Java, there are a number of classes / interfaces that basically correspond to this Example (details soon): Runnable work done by method run() [PAGE 4] Java: Statements \ue000 Tasks Consecutive lines of code: Interchanging: tmp = f1; f1 = f2; f2 = tmp; A method: swap(f1, f2); A \u201ctask\u201d object:",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_1",
    "text": "SwapTask task1= new SwapTask(f1,f2); task1.run(); [PAGE 5] Why a task object? Actions, functions vs. objects. What\u2019s the difference? Objects: Are persistent. Can be stored. Can be created and then used later. Can be attached to other things. Put in Collections. Contain state. Functions: Called, return (not permanent) [PAGE 6] Java Library Classes For task-like things: Runnable, Callable SwingWorker, RecursiveAction, etc. Thread class Managing tasks and threads Executor, ExecutorService ForkJoinPool In Swing The Event-Dispatch Thread SwingUtilities.invokeLater() [PAGE 7] Java\u2019s Nested Classes You can declare a class inside another class. If declared static, can use just like any class. If not static Can only define objects of that type from within non-static code of the enclosing class Object of inner-class type can access all fields of the object that created it. (Useful!) Often used for \u201chelper\u201d classes, e.g. a node object used in a list or tree. See demo done in Eclipse: TaskDemo.java [PAGE 8] Multitasking and Multithreading Multitasking: refers to a computer's ability to perform multiple jobs concurrently more than one program are running concurrently, e.g., UNIX Multithreading: A thread is a single sequence of execution within a program refers to multiple threads of control within a single program each program",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_2",
    "text": "can run multiple threads of control within it, e.g., Web Browser [PAGE 9] Concurrency vs. Parallelism CPU CPU1 CPU2 [PAGE 10] What are Threads Good For? To maintain responsiveness of an application during a long running task To enable cancellation of separable tasks Some problems are intrinsically parallel To monitor status of some resource (e.g., DB) Some APIs and systems demand it (e.g., Swing) [PAGE 11] Application Thread When we execute an application: 1. The JVM creates a Thread object whose task is defined by the main() method 2. The JVM starts the thread 3. The thread executes the statements of the program one by one 4. After executing all the statements, the method returns and the thread dies [PAGE 12] Multiple Threads in an Application Each thread has its private run-time stack If two threads execute the same method, each will have its own copy of the local variables the methods uses However, all threads see the same dynamic memory, i.e., heap (are there variables on the heap?) Two different threads can act on the same object and same static fields concurrently [PAGE 13] The Class Thread Thread provides a constructor plus methods start, stop, run, interrupt, suspend, set",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_3",
    "text": "priorities, get status, and resume threads. public Thread() -- constructor for a new thread. This or the constructor for a subclass is called by the client process to create a new thread. public void start() -- Called by client process to request that the Java runtime system run this thread instance. public void run() -- We override this method to perform the work that we want done by the thread. public void stop() -- (deprecated) Usually called by the client process to stop the thread. public void interrupt() -- Usually called by the client process to get the thread\u2019s attention, e.g., so that it can exit its run method and thereby stop. [PAGE 14] Example: ThreadDemo.java // ThreadDemo.java public class ThreadDemo { public static void main( String[] args) { CountingThread aCounter = new CountingThread(\"a\"); CountingThread bCounter = new CountingThread(\"b\"); aCounter.start(); bCounter.start(); } } [PAGE 15] Class CountingThread (for ThreadDemo) public class CountingThread extends Thread { String context; public CountingThread(String context) { this.context = context; } public void run() { for (int i = 0; i < 50; i++) { System.out.print(context + i + context + \" \"); } } } [PAGE 16] (base) ganesan@ganesan:~/Desktop/gg$ java ThreadDemo a0a a1a a2a a3a",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_4",
    "text": "a4a a5a a6a a7a a8a a9a a10a a11a a12a a13a a14a a15a a16a a17a a18a a19a a20a a21a a22a a23a a24a a25a a26a a27a a28a a29a a30a a31a a32a a33a a34a a35a a36a a37a a38a a39a a40a a41a a42a a43a a44a a45a a46a a47a a48a a49a b0b b1b b2b b3b b4b b5b b6b b7b b8b b9b b10b b11b b12b b13b b14b b15b b16b b17b b18b b19b b20b b21b b22b b23b b24b b25b b26b b27b b28b b29b b30b b31b b32b b33b b34b b35b b36b b37b b38b b39b b40b b41b b42b b43b b44b b45b b46b b47b b48b b49b [PAGE 17] Creating Threads There are two ways to create our own object Thread 1. Subclassing the Thread class and instantiating a new object of that class 2. Implementing the Runnable interface In both cases the method should be run() implemented [PAGE 18] Extending Thread public class ThreadExample extends Thread { public void run () { for (int i = 1; i <= 100; i++) { System.out.println(\u201c---\u201d); } } } [PAGE 19] Thread Methods void start() Creates a new thread and makes it runnable This method can be called only once void run() The new thread begins its life inside this method void stop()",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_5",
    "text": "(deprecated) The thread is being terminated [PAGE 20] Thread Methods void yield() Causes the currently executing thread object to temporarily pause and allow other threads to execute Allow only threads of the same priority to run void sleep(int m) or sleep(int m, int n) The thread sleeps for m milliseconds, plus n nanoseconds [PAGE 21] Implementing Runnable class RunnableExample implements Runnable { public void run () { for (int i = 1; i <= 50; i++) { System.out.println (\u201c***\u201d); } } } [PAGE 22] A Runnable Object When running the Runnable object, a Thread object is created from the Runnable object The Thread object\u2019s run() method calls the Runnable object\u2019s run() method Allows threads to run inside any object, regardless of inheritance Example \u2013 an applet that is also a thread 22 [PAGE 23] Starting the Threads public class ThreadsStartExample { public static void main (String argv[]) { new ThreadExample ().start (); new Thread(new RunnableExample ()).start (); } New ThreadStartExample(); } What will we see when running ThreadsStartExample? [PAGE 24] (base) ganesan@ganesan:~/Desktop/gg$ java ThreadStartExample *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_6",
    "text": "*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** [PAGE 25] Handling threads in an Applet Declare your Applet subclass to implement Runnable. public void run() {...} //Add this to do the work. What if the browser goes to another web page or quits? Provide a way for the browser to not only suspend the main thread, but also to suspend and resume any extra threads: public void start() { extraThread.resume(); } public void stop() { extraThread.timeToSleep=true(); extraThread.interrupt(); } public void destroy() { extraThread.timeToQuit=true(); extraThread.interrupt(); } [PAGE 26] Example: Clock Applet // Clock.java import java.awt.*; import java.applet.*; import java.util.*; public class Clock extends Applet implements Runnable { class TimeThread extends Thread { boolean timeToQuit = false; public TimeThread(Runnable r) { super(r); } } TimeThread timeThread; public Clock() { } public void init() { timeThread = new TimeThread(this); timeThread.start(); } [PAGE 27] Clock Applet (continued) public void paint(Graphics g) { g.drawString(\"The time is: \" + (new Date()), 100, 50); } public void run() { while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { if (timeThread.timeToQuit) return; } repaint(); } } public void start() {}",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_7",
    "text": "public void stop() {} public void destroy() { timeThread.timeToQuit = true; timeThread.interrupt(); } } [PAGE 28] Appearance of the Clock Applet This is a test of the Clock applet. The time is Fri Oct 25 01:32:00 PDT 2013 Note: Java Applet is deprecated since Java 9. It means Applet API is no longer considered important. [PAGE 29] Thread State (with deprecated methods) create new start run running ready yield suspend or sleep stop resume stop inactive finished stop [PAGE 30] Thread State (with new methods) create new start run running ready yield, interrupt wait, join, or sleep interrupt return inactive finished [PAGE 31] Thread States [PAGE 32] Thread Priority Determines how thread should be treated with respect to the others. Context switch - A thread\u2019s priority is used to decide when to switch from one running thread to the next thread The rules that determine when a context switch are A thread can voluntarily relinquish control: This is done by explicitly yielding, sleeping, or blocking on pending I/O. In this scenario, all other threads are observe, and the highest-priority thread that is ready to run is given the CPU. [PAGE 33] Thread Priority A thread can be preempted by a",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_8",
    "text": "higher-priority thread: In this case, a lower-priority thread that does not yield the processor is simply preempted\u2014no matter what it is doing\u2014by a higher-priority thread. Basically, as soon as a higher-priority thread wants to run, it does. This is called preemptive multitasking. [PAGE 34] Thread Priority 1 = MIN_PRIORITY, 5= MED_PRIORITY, 10 = MAX_PRIORITY int P = myThread.getPriority(); myThread.setPriority(Thread.MAX_PRIORITY); As long as a thread of priority P is in the ready state, no thread of priority less than P will be moved to the runnable state. For threads of equal priority, CPU resources are shared, round-robin style. [PAGE 35] Thread Groups When a number of threads are to be handled in the same manner, they can be put in a thread group. ThreadGroup tg = new ThreadGroup(\u201cmy sprites\u201d); There\u2019s a Thread constructor that takes a group as an arg. public Thread(ThreadGroup g, Runnable target, String name); There are many methods for ThreadGroup objects such as getMaxPriority, destroy, etc. ThreadGroups can contain ThreadGroups. Trees of ThreadGroups are therefore possible. [PAGE 36] Application to Animation Animation requires controlled timing. A thread that uses the sleep(int) method can handle timed updates to a display. Multiple threads can concurrent tasks, but synchronization may become",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_9",
    "text": "an issue. Therefore a single animation thread (but separate from the main thread) often works best. The main thread handles the user interface and other activities that are logically separate from those belonging to the animation. [PAGE 37] Synchronization Two threads to communicate and share a complicated data structure, more than one write at a time. Once a thread enters a monitor, all other threads must wait until that thread exits the monitor. Once a thread is inside a synchronized method, no other thread can call any other synchronized method on the same object [PAGE 38] Synchronization Messaging Threads to communicate with each other. \u25aa Taken care by Java and not by Operating System. \u25aa Allows a thread to enter a synchronized method on an \u25aa object, and then wait there until some other thread explicitly notifies it to come out. [PAGE 39] Thread Class Methods Method Meaning getName Obtain a thread\u2019s name. getPriority Obtain a thread\u2019s priority isAlive Determine if a thread is still running. join Wait for a thread to terminate run Entry point for the thread. sleep Suspend a thread for a period of time. start Start a thread by calling its run method. [PAGE 40] Alive",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_10",
    "text": "Thread State Diagram New Dead Thread Thread Running new ThreadExample(); while (\u2026) { \u2026 } Runnabl e thread.sta run() method rt(); returns Blocked Object.wait() Thread.sleep() blocking IO call waiting on a monitor [PAGE 41] Example public class PrintThread1 extends Thread { String name; public PrintThread1(String name) { this.name = name; } public void run() { for (int i=1; i<100 ; i++) { try { sleep((long)(Math.random() * 100)); } catch (InterruptedException ie) { } System.out.print(name); } } 41 [PAGE 42] Example (cont) public static void main(String args[]) { PrintThread1 a = new PrintThread1(\"*\"); PrintThread1 b = new PrintThread1(\"-\"); a.start(); b.start(); } } 42 [PAGE 43] 43 [PAGE 44] Multithreading - Introduction A multithreaded program contains two or more parts that can run concurrently. Each part of such a program is called a thread, and each thread defines a separate path of execution. It is a specialized form of multitasking. Multitasking: process-based and thread-based Process-based: (A program in execution \u2013 process) run two or more programs concurrently Thread-based: Thread is the smallest unit of dispatchable code. For instance, a text editor can format text at the same time that it is printing, as long as these two actions are being performed by",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_11",
    "text": "two separate threads. 44 [PAGE 45] Multithreading - Introduction Threads are lightweight process. They share the same address space. Inter-thread communication is inexpensive, and context switching from one thread to the next is low cost. 45 [PAGE 46] Scheduling Thread scheduling is the mechanism used to determine how runnable threads are allocated CPU time A thread-scheduling mechanism is either preemptive or nonpreemptive 46 [PAGE 47] Preemptive Scheduling Preemptive scheduling \u2013 the thread scheduler preempts (pauses) a running thread to allow different threads to execute Nonpreemptive scheduling \u2013 the scheduler never interrupts a running thread The nonpreemptive scheduler relies on the running thread to yield control of the CPU so that other threads may execute 47 [PAGE 48] Starvation A nonpreemptive scheduler may cause starvation (runnable threads, ready to be executed, wait to be executed in the CPU a very long time, maybe even forever) Sometimes, starvation is also called a livelock 48 [PAGE 49] Time-Sliced Scheduling Time-sliced scheduling the scheduler allocates a period of time that each thread can use the CPU when that amount of time has elapsed, the scheduler preempts the thread and switches to a different thread Nontime-sliced scheduler the scheduler does not use elapsed time to",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_12",
    "text": "determine when to preempt a thread it uses other criteria such as priority or I/O status 49 [PAGE 50] Java Scheduling Scheduler is preemptive and based on priority of threads Uses fixed-priority scheduling: Threads are scheduled according to their priority w.r.t. other threads in the ready queue 50 [PAGE 51] Java Scheduling The highest priority runnable thread is always selected for execution above lower priority threads When multiple threads have equally high priorities, only one of those threads is guaranteed to be executing Java threads are guaranteed to be preemptive-but not time sliced Q: Why can\u2019t we guarantee time-sliced scheduling? What is the danger of such scheduler? 51 [PAGE 52] Thread Priority Every thread has a priority When a thread is created, it inherits the priority of the thread that created it The priority values range from 1 to 10, in increasing priority 52 [PAGE 53] Thread Priority (cont.) The priority can be adjusted subsequently using the method setPriority() The priority of a thread may be obtained using getPriority() Priority constants are defined: MIN_PRIORITY=1 The main thread is MAX_PRIORITY=10 created with priority NORM_PRIORITY=5 NORM_PRIORITY 53 [PAGE 54] Some Notes Thread implementation in Java is actually based on operating system support",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_13",
    "text": "Some Windows operating systems support only 7 priority levels, so different levels in Java may actually be mapped to the same operating system level What should we do about this? Furthermore, The thread scheduler may choose to run a lower priority thread to avoid starvation 54 [PAGE 55] Daemon Threads Daemon threads are \u201cbackground\u201d threads, that provide services to other threads, e.g., the garbage collection thread The Java VM will not exit if non-Daemon threads are executing The Java VM will exit if only Daemon threads are executing Daemon threads die when the Java VM exits Q: Is the main thread a daemon thread? 55 [PAGE 56] Thread and the Garbage Collector Can a Thread object be collected by the garbage collector while running? If not, why? If yes, what happens to the execution thread? When can a Thread object be collected? 56 [PAGE 57] ThreadGroup The ThreadGroup class is used to create groups of similar threads. Why is this needed? \u201cThread groups are best viewed as an unsuccessful experiment, and you may simply ignore their existence.\u201d Joshua Bloch, software architect at Sun 57 [PAGE 59] Executors An Executor is an object that manages running tasks Submit a Runnable to",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_14",
    "text": "be run with Executor\u2019s execute() method So, instead of creating a Thread for your Runnable and calling start() on that, do this: Get an Executor object, say called exec Create a Runnable, say called myTask Submit for running: exec execute(myTask) [PAGE 60] How to Get an Executor Use static methods in Executors library. Fixed \u201cthread pool\u201d: at most N threads running at one time Executor exec = Executors.newFixedThreadPool(MAX_THREADS); Unlimited number of threads Executor exec = Executors.newCachedThreadPool(); [PAGE 61] Concurrency and Synchronization Concurrency: Issues related to multiple-threads accessing shared data Synchronization: Methods to manage and control concurrent access to shared data by multiple-threads Note: Our book defines concurrent programming and concurrency to be what [PAGE 62] Possible Bugs in Multithreaded Code Possible bug #1 i=1; x=10; x = i + x; // x could be 12 here Possible bug #2 if ( ! myList.contains(x) ) myList.add(x); // x could be in list twice [PAGE 63] Here\u2019s Why See MSD text pp. 759-762 Multiple threads executing same lines of code at \u201csame\u201d time, accessing same data values [PAGE 64] How 1 + 10 might be 12 Thread 1 executes: Thread 2 executes: (x is 10, i is 1) (x is 10, i",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_15",
    "text": "is 1) Get i (1) into register 1 (other thread has CPU) Get x (10) into its register 2 (other thread has CPU) (other thread has CPU) \u2013Get i (1) into its register 1 Add registers (other thread has CPU) Store result (11) into x (other thread has CPU) (x is now 11) \u2013Get x (11) into is register 2 (other thread has CPU) \u2013Add registers (other thread has CPU) \u2013Store result (12) into x Do next line of code (x is now 12) (x changes to 12 even [PAGE 65] Synchronization Understand the issue with concurrent access to shared data? Data could be a counter (int) or a data structure (e.g. a Map or List or Set) A race condition: Two threads will access something. They \u201ccompete\u201d causing a problem A critical section: a block of code that can only be safely executed by one thread at a time A lock: an object that is \u201cheld\u201d by one thread at a time, then \u201creleased\u201d [PAGE 66] Synchronization in Java (1) Any object can serve as a lock Separate object: Object myLock = new Object(); Current instance: the this object Enclose lines of code in a synchronized block synchronized(myLock) {",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_16",
    "text": "// code here } More than one thread could try to execute this code, but one acquires the lock and the others \u201cblock\u201d or wait until the first thread releases the lock [PAGE 67] Synchronized Methods Common situation: all the code in a method is a critical section I.e. only one thread at a time should execute that method E.g. a getter or setter or mutator, or something that changes shared state info (e.g. a Map of important data) Java makes it easy: add synchronized keyword to method signature. E.g. public synchronized void update(\u2026) { [PAGE 68] Summary So Far Concurrent access to shared data Can lead to serious, hard-to-find problems E.g. race conditions The concept of a lock Synchronized blocks of code or methods One thread at a time While first thread is executing it, others block [PAGE 69] Java Serialization 69 [PAGE 70] Serialization basics Serialization is the process of transforming an in-memory object to a byte stream. Deserialization is the inverse process of reconstructing an object from a byte stream to the same state in which the object was previously serialized. \u201cSerializing out\u201d and \u201cserializing in\u201d are also used. [PAGE 71] The requirements for serialization are straightforward:",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_17",
    "text": "Only class instances rather than primitive types can be serialized. For an object to be serializable, its class or some ancestor must implement the empty Serializable interface. An empty interface is called a marker interface. [PAGE 72] The syntax for serialization is straightforward: An object is serialized by writing it to an ObjectOutputStream. An object is deserialized by reading it from an ObjectInputStream. [PAGE 73] Serialization code FileOutputStream out = new FileOutputStream( \u201csave.ser\u201d ); ObjectOutputStream oos = new ObjectOutputStream( out ); oos.writeObject( new Date() ); oos.close(); [PAGE 74] Deserialization code FileInputStream in = new FileInputStream( \u201csave.ser\u201d ); ObjectInputStream ois = new ObjectInputStream( in ); Date d = (Date) ois.readObject(); ois.close(); [PAGE 75] Object graphs If an object has references to other objects or arrays, the entire object graph is serialized when the object is serialized. The object graph consists of the object directly serialized and any other objects or arrays to which the object has direct or indirect references. [PAGE 76] Nonserializable superclasses If a serializable class C has a nonserializable superclass S, instances of C still can be serialized if S has an accessible no-argument constructor. S\u2019s no-argument constructor is invoked automatically during deserialization to construct the \u201cS-part\u201d of",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_18",
    "text": "the deserialized object. [PAGE 77] Serialization and primitive types Technically, primitive types cannot be serialized or deserialized. However, the ObjectOutputStream implements the DataOutput interface, which declares methods such as writeInt to write primitive types to streams. ObjectInputStream implements DataInput for reading primitive types. [PAGE 78] and fields transient static A field marked as transient is not impacted by serialization. During deserialization, transient fields are restored to their default values (e.g., transient numeric fields are restored to zero). static fields are not impacted by serialization. [PAGE 79] Customization Serialization and deserialization can be customized by providing private callback methods named writeObject and readObject, respectively. The Externalizable interface can be implemented by classes that need to have complete control over serialization and deserialization. [PAGE 80] Conclusion The same object should not be repeatedly serialized to the same stream. A class should not be redefined in between the serialization and deserialization of its instances. Classes that need to disable serialization can throw a NotSerializableException in the [PAGE 82] More Advanced Synchronization A semaphore object Allows simultaneous access by N threads If N==1, then this is known as a mutex (mutual exclusion) Java has a class Semaphore Other Java classes CountDownLatch, Barriers, etc. No",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_19",
    "text": "more on these in CS2110 this term [PAGE 83] Using CountDownLatch Here are some common scenarios and demo programs for them You\u2019ll use the last of these for the War card-game program! [PAGE 84] Scenario #1 A \u201cmanager\u201d thread and N \u201cworker\u201d threads Manager starts workers but then must wait for them to finish before doing follow-up work Solution: Manager creates a CountDownLatch with value N After workers starts, manager calls await() on that When each worker completes its work, it calls countDown() on the latch After all N call countDown(), manager is un-blocked and does follow-up work Example use: parallel divide and conquer like mergesort Code example: SyncDemo0.java [PAGE 85] Thread Rules in Swing All operations that update GUI components must happen in the EDT These components are not thread-safe (later) SwingUtilities.invokeLater(Runnable r) is a method that runs a task in the EDT when appropriate But execute slow tasks in separate worker threads To make common tasks easier, use a [PAGE 86] SwingWorker A class designed to be extended to define a task for a worker thread Override method doInBackground() This is like run() \u2013 it\u2019s what you want to do Override method done() This method is for updating",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_20",
    "text": "the GUI afterwards It will be run in the EDT For more info, see: http://download.oracle.com/javase/tutorial/uiswing/concurrency/ [PAGE 87] Code Example We have a fibonacci demo that runs this method both recursively and with a loop Original version Unresponsive until it completes all its calculations Need to run calls to the recursive fibonacci in a separate thread See Fib2.java that uses SwingWorker to define a task [PAGE 89] New Java ForkJoin Framework Designed to support a common need Recursive divide and conquer code Look for small problems, solve without parallelism For larger problems Define a task for each subproblem Library provides a Thread manager, called a ForkJoinPool Methods to send your subtask objects to the pool to be run, and your call waits until their done [PAGE 90] Turns out that Java\u2019s threads are still too \u201cheavy-weight\u201d Will be in Java 7 standard libraries, but available in Java 6 as a downloaded .jar file Get jsr166y.jar from http://gee.cs.oswego.edu/dl/concurrency-interest/index.html More info here http://www.cs.washington.edu/homes/djg/teachingMaterials/grossmanS PAC forkJoinFramework html [PAGE 91] Screenshots: For single- and multi-threaded Mergesort: Threads in Eclipse Debug window, and Mac\u2019s CPU usage display text [PAGE 92] The ForkJoinPool The \u201cthread manager\u201d Used when calls are made to RecursiveTask\u2019s methods fork(), invokeAll(), etc.",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_21",
    "text": "When created, knows how many processors are available Pretty sophisticated \u201cSteals\u201d time from threads that have nothing to do [PAGE 93] Overview of How To Create a ForkJoinPool \u201cthread-manager\u201d object Create a task object that extends RecursiveTask We\u2019ll ignore use of generics with this (see docs) Create a task-object for entire problem and call invoke(task) on your ForkJoinPool Your task class\u2019 compute() is like Thread.run() It has the code to do the divide and conquer First, it must check if small problem \u2013 don\u2019t use parallelism, solve without it Then, divide and create >1 new task-objects. Run them: [PAGE 94] Same Ideas as Thread But... To use the ForkJoin Framework: A little standard set-up code (e.g., create a ForkJoinPool) Don\u2019t subclass Thread Do subclass RecursiveTask<V> Don\u2019t override run Do override compute Don\u2019t call start Do call invoke, invokeAll, fork Don\u2019t just call join Do call join which returns answer or Do call invokeAll on multiple tasks [PAGE 95] Mergesort Example Top-level call. Create \u201cmain\u201d task and submit public static void mergeSortFJRecur(Comparable[] list, int first, int last) { if (last - first < RECURSE_THRESHOLD) { MergeSort.insertionSort(list, first, last); return; } [PAGE 96] Mergesort\u2019s Task-Object Nested Class static class SortTask extends RecursiveAction",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_22",
    "text": "{ Comparable[] list; Comparable[] tmpList; int first, last; public SortTask(Comparable[] a, Comparable[] tmp, int lo, int hi) { this.list = a; this.tmpList = tmp; this.first = lo; this.last = hi; } // continued next slide [PAGE 97] compute() Does Task Recursion protected void compute() { // in SortTask, continued from previous slide if (last - first < RECURSE_THRESHOLD) MergeSort.insertionSort(list, first, last); else { int mid = (first + last) / 2; // the two recursive calls are replaced by a call to invokeAll SortTask task1 = new SortTask(list, tmpList, first, mid); [PAGE 98] Leaving new ForkJoin framework\u2026 Java since 1.5 has a more general set of classes for \u201ctask managers\u201d [PAGE 99] Nice to Have a Thread \u201cManager\u201d If your code is responsible for creating a bunch of tasks, linking them with Threads, and starting them all, then you have muchto worry about: What if you start too many threads? Can you manage the number of running threads? Enough processors? Can you shutdown all the threads? [PAGE 100] Executors An Executor is an object that manages running tasks Submit a Runnable to be run with Executor\u2019s execute() method So, instead of creating a Thread for your Runnable and calling start()",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_23",
    "text": "on that, do this: Get an Executor object, say called exec Create a Runnable, say called myTask Submit for running: exec execute(myTask) [PAGE 101] How to Get an Executor Use static methods in Executors library. Fixed \u201cthread pool\u201d: at most N threads running at one time Executor exec = Executors.newFixedThreadPool(MAX_THREADS); Unlimited number of threads Executor exec = Executors.newCachedThreadPool(); [PAGE 102] Summary So Far Create a class that implements a Runnable to be your \u201ctask object\u201d Or if ForkJoin framework, extend RecursiveTask Create your task objects Create an Executor Or a ForkJoinPool Submit each task-object to the Executor which starts it up in a separate thread [PAGE 103] Concurrency and Synchronization Concurrency: Issues related to multiple-threads accessing shared data Synchronization: Methods to manage and control concurrent access to shared data by multiple-threads Note: Our book defines concurrent programming and concurrency to be what [PAGE 104] Possible Bugs in Multithreaded Code Possible bug #1 i=1; x=10; x = i + x; // x could be 12 here Possible bug #2 if ( ! myList.contains(x) ) myList.add(x); // x could be in list twice [PAGE 105] Here\u2019s Why See MSD text pp. 759-762 Multiple threads executing same lines of code at \u201csame\u201d time,",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_24",
    "text": "accessing same data values [PAGE 106] How 1 + 10 might be 12 Thread 1 executes: Thread 2 executes: (x is 10, i is 1) (x is 10, i is 1) Get i (1) into register 1 (other thread has CPU) Get x (10) into its register 2 (other thread has CPU) (other thread has CPU) \u2013Get i (1) into its register 1 Add registers (other thread has CPU) Store result (11) into x (other thread has CPU) (x is now 11) \u2013Get x (11) into is register 2 (other thread has CPU) \u2013Add registers (other thread has CPU) \u2013Store result (12) into x Do next line of code (x is now 12) (x changes to 12 even [PAGE 107] Synchronization Understand the issue with concurrent access to shared data? Data could be a counter (int) or a data structure (e.g. a Map or List or Set) A race condition: Two threads will access something. They \u201ccompete\u201d causing a problem A critical section: a block of code that can only be safely executed by one thread at a time A lock: an object that is \u201cheld\u201d by one thread at a time, then \u201creleased\u201d [PAGE 108] Synchronization in Java (1)",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_25",
    "text": "Any object can serve as a lock Separate object: Object myLock = new Object(); Current instance: the this object Enclose lines of code in a synchronized block synchronized(myLock) { // code here } More than one thread could try to execute this code, but one acquires the lock and the others \u201cblock\u201d or wait until the first thread releases the lock [PAGE 109] Synchronized Methods Common situation: all the code in a method is a critical section I.e. only one thread at a time should execute that method E.g. a getter or setter or mutator, or something that changes shared state info (e.g. a Map of important data) Java makes it easy: add synchronized keyword to method signature. E.g. public synchronized void update(\u2026) { [PAGE 110] Summary So Far Concurrent access to shared data Can lead to serious, hard-to-find problems E.g. race conditions The concept of a lock Synchronized blocks of code or methods One thread at a time While first thread is executing it, others block [PAGE 111] Some Java Solutions There are some synchronized collections Classes like AtomicInteger Stores an int Has methods to operate on it in a thread-safe manner int getAndAdd(int delta) instead of i=i+1 [PAGE",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_26",
    "text": "112] More Advanced Synchronization A semaphore object Allows simultaneous access by N threads If N==1, then this is known as a mutex (mutual exclusion) Java has a class Semaphore Other Java classes CountDownLatch, Barriers, etc. No more on these in CS2110 this term [PAGE 113] Unused slides for Spring 2011 [PAGE 114] Barriers Java class CyclicBarrier A rendezvous point or barrier point Worker threads wait at a spot until all get there Then all proceed [PAGE 115] Using CountDownLatch Here are some common scenarios and demo programs for them You\u2019ll use the last of these for the War card-game program! [PAGE 116] Scenario #1 A \u201cmanager\u201d thread and N \u201cworker\u201d threads Manager starts workers but then must wait for them to finish before doing follow-up work Solution: Manager creates a CountDownLatch with value N After workers starts, manager calls await() on that When each worker completes its work, it calls countDown() on the latch After all N call countDown(), manager is un-blocked and does follow-up work Example use: parallel divide and conquer like mergesort Code example: SyncDemo0.java [PAGE 117] Scenario #2 A \u201cmanager\u201d thread and N \u201cworker\u201d threads Manager starts workers but wants them to \u201chold\u201d before doing real work",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_27",
    "text": "until it says \u201cgo\u201d Solution: Manager creates a CountDownLatch with value 1 After each workers start, it calls await() on that Latch At some point, when ready, the manager calls countDown() on that Latch Now Workers free to continue with their work Code example: SyncDemo1.java [PAGE 118] Scenario #3 Work done in \u201crounds\u201d where: All workers wait for manager to say \u201cgo\u201d Each worker does its job and then waits for next round Manager waits for all workers to complete a round, then does some follow-up work When that\u2019s done, manager starts next round by telling workers \u201cgo\u201d Solution: combine the two previous solutions First Latch: hold workers until manager is ready Second Latch: manager waits until workers finish a round Worker\u2019s run() has loop to repeat Manager must manage Latches, recreating them at end of round Example use: a card game or anything that has that kind of structure Code example: SyncDemo2.java [PAGE 119] Summary of last section Multiple threads may need to cooperate Common situation: some workers and a manager One thread may need to wait for one or more thread to complete One or more threads may need to wait to be \u201creleased\u201d Or a combination of",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_28",
    "text": "these situations Threads all access a CountDownLatch await() used to wait for enough calls to countDown() [PAGE 120] Multithreading Client-Server 120 [PAGE 121] HelloServer \u2026 ConnectionHandler ConnectionHandler HelloClient HelloClient 121 [PAGE 122] Server import java.net.*;import java.io.*; class HelloServer { public static void main(String[] args) { int port = Integer.parseInt(args[0]); try { ServerSocket server = new ServerSocket(port); } catch (IOException ioe) { System.err.println(\u201cCouldn't run \u201c + \u201cserver on port \u201c + port); return; } 122 [PAGE 123] while(true) { try { Socket connection = server.accept(); ConnectionHandler handler = new ConnectionHandler(connection); new Thread(handler).start(); } catch (IOException ioe1) { } } 123 [PAGE 124] Connection Handler // Handles a connection of a client to an HelloServer. // Talks with the client in the 'hello' protocol class ConnectionHandler implements Runnable { // The connection with the client private Socket connection; public ConnectionHandler(Socket connection) { this.connection = connection; } 124 [PAGE 125] public void run() { try { BufferedReader reader = new BufferedReader( new InputStreamReader( connection.getInputStream())); PrintWriter writer = new PrintWriter( new OutputStreamWriter( connection.getOutputStream())); String clientName = reader.readLine(); writer.println(\u201cHello \u201c + clientName); writer.flush(); } catch (IOException ioe) {} } 125 } [PAGE 126] Client side import java.net.*; import java.io.*; // A client of an HelloServer",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_29",
    "text": "class HelloClient { public static void main(String[] args) { String hostname = args[0]; int port = Integer.parseInt(args[1]); Socket connection = null; try { connection = new Socket(hostname, port); } catch (IOException ioe) { System.err.println(\"Connection failed\"); return; } 126 [PAGE 127] try { BufferedReader reader = new BufferedReader( new InputStreamReader( connection.getInputStream())); PrintWriter writer = new PrintWriter( new OutputStreamWriter( connection.getOutputStream())); writer.println(args[2]); // client name String reply = reader.readLine(); System.out.println(\"Server reply: \"+reply); writer.flush(); } catch (IOException ioe1) { Note that the Client has not } changed from the } networking-lecture example 127 [PAGE 128] Concurrency An object in a program can be changed by more than one thread Q: Is the order of changes that were preformed on the object important? 128 [PAGE 129] Race Condition A race condition \u2013 the outcome of a program is affected by the order in which the program's threads are allocated CPU time Two threads are simultaneously modifying a single object Both threads \u201crace\u201d to store their value 129 [PAGE 130] Race Condition Example How can we have Put red pieces Put green pieces alternating colors? 130 [PAGE 131] Monitors Each object has a \u201cmonitor\u201d that is a token used to determine which application thread has control",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_30",
    "text": "of a particular object instance In execution of a synchronized method (or block), access to the object monitor must be gained before the execution Access to the object monitor is queued 131 [PAGE 132] Monitor (cont.) Entering a monitor is also referred to as locking the monitor, or acquiring ownership of the monitor If a thread A tries to acquire ownership of a monitor and a different thread has already entered the monitor, the current thread (A) must wait until the other thread leaves the monitor 132 [PAGE 133] Critical Section The synchronized methods define critical sections Execution of critical sections is mutually exclusive. Why? 133 [PAGE 134] Example public class BankAccount { private float balance; public synchronized void deposit(float amount){ balance += amount; } public synchronized void withdraw(float amount){ balance -= amount; } } 134 [PAGE 135] Critical Sections t t t 3 2 1 deposi t() Bank Account 135 [PAGE 136] Java Locks are Reentrant Is there a problem with the following code? public class Test { public synchronized void a() { b(); System.out.println(\u201cI am at a\u201d); } public synchronized void b() { System.out.println(\u201cI am at b\u201d); } } 136 [PAGE 137] Static Synchronized Methods Marking a static",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_31",
    "text": "method as synchronized, associates a monitor with the class itself The execution of synchronized static methods of the same class is mutually exclusive. Why? 137 [PAGE 138] Synchronized Statements A monitor can be assigned to a block: synchronized(object) { some-code } It can also be used to monitor access to a data element that is not an object, e.g., array: void arrayShift(byte[] array, int count) { synchronized(array) { System.arraycopy (array, count, array, 0, array.size - count); } } 138 [PAGE 139] The Followings are Equivalent public synchronized void a() { //\u2026 some code \u2026 } public void a() { synchronized (this) { //\u2026 some code \u2026 } } 139 [PAGE 140] The Followings are Equivalent public static synchronized void a() { //\u2026 some code \u2026 } public void a() { synchronized (this.getClass()) { //\u2026 some code \u2026 } } 140 [PAGE 141] Example public class MyPrinter { public MyPrinter() {} public synchronized void printName(String name) { for (int i=1; i<100 ; i++) { try { Thread.sleep((long)(Math.random() * 100)); } catch (InterruptedException ie) {} System.out.print(name); } } } 141 [PAGE 142] Example public class PrintThread2 extends Thread { String name; MyPrinter printer; public PrintThread2(String name, MyPrinter printer){ this.name = name; this.printer",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_32",
    "text": "= printer; } public void run() { printer.printName(name); } } 142 [PAGE 143] Example (cont) public class ThreadsTest2 { public static void main(String args[]) { MyPrinter myPrinter = new MyPrinter(); PrintThread2 a = new PrintThread2(\"*\u201c, printer); PrintThread2 b = new PrintThread2(\"-\u201c, printer); PrintThread2 c = new PrintThread2(\"=\u201c, printer); a.start(); b.start(); c.start(); } What will happen? } 143 [PAGE 144] 144 [PAGE 145] Deadlock Example public class BankAccount { private float balance; public synchronized void deposit(float amount) { balance += amount; } public synchronized void withdraw(float amount) { balance -= amount; } public synchronized void transfer (float amount, BankAccount target) { withdraw(amount); target.deposit(amount); } 145 } [PAGE 146] public class MoneyTransfer implements Runnable { private BankAccount from, to; private float amount; public MoneyTransfer( BankAccount from, BankAccount to, float amount){ this.from = from; this.to = to; this.amount = amount; } public void run() { source.transfer(amount, target); } } 146 [PAGE 147] BankAccount aliceAccount = new BankAccount(); BankAccount bobAccount = new BankAccount(); ... // At one place Runnable transaction1 = new MoneyTransfer(aliceAccount, bobAccount, 1200); Thread t1 = new Thread(transaction1); t1.start(); // At another place Runnable transaction2 = new MoneyTransfer(bobAccount, aliceAccount, 700); Thread t2 = new Thread(transaction2); t2.start(); 147 [PAGE 148] Deadlocks t t",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_33",
    "text": "1 2 aliceAcco bobAcco unt unt transf transf er() er() ? withdra withdra w() w() deposi deposi t() t() 148 [PAGE 149] Thread Synchronization We need to synchronized between transactions, for example, the consumer-producer scenario 149 [PAGE 150] Wait and Notify Allows two threads to cooperate Based on a single shared lock object Marge put a cookie wait and notify Homer Homer eat a cookie wait and notify Marge Marge put a cookie wait and notify Homer Homer eat a cookie wait and notify Marge 150 [PAGE 151] The Method wait() The method is part of the wait() interface java.lang.Object It requires a lock on the object\u2019s monitor to execute It must be called from a synchronized method, or from a synchronized segment of code. Why? 151 [PAGE 152] The wait() Method wait() causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object Upon call for wait(), the thread releases ownership of this monitor and waits until another thread notifies the waiting threads of the object 152 [PAGE 153] The wait() Method is also similar to wait() yield() Both take the current thread off the execution stack and force it",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_34",
    "text": "to be rescheduled However, is not automatically put back into wait() the scheduler queue notify() must be called in order to get a thread back into the scheduler\u2019s queue The objects monitor must be reacquired before the thread\u2019s run can continue What is the difference between wait and sleep? 153 [PAGE 154] Consumer Consumer: synchronized (lock) { while (!resourceAvailable()) { lock.wait(); } consumeResource(); } 154 [PAGE 155] Producer Producer: produceResource(); synchronized (lock) { lock.notifyAll(); } 155 [PAGE 156] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8.Return from wait() Consumer Producer Thread Thread 156 [PAGE 157] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait() Consumer Producer Thread Thread 157 [PAGE 158] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait() Consumer Producer Thread Thread 158 [PAGE 159] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_35",
    "text": "from wait() Consumer Producer Thread Thread 159 [PAGE 160] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait() Consumer Producer Thread Thread 160 [PAGE 161] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait() Consumer Producer Thread Thread 161 [PAGE 162] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait() Consumer Producer Thread Thread 162 [PAGE 163] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait() Consumer Producer Thread Thread 163 [PAGE 164] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait() Consumer Producer Thread Thread 164 [PAGE 165] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait()",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_36",
    "text": "Consumer Producer Thread Thread 165 [PAGE 166] Wait/Notify Sequence Lock Object 1. synchronized(lock){ 3. produceResource() 4. synchronized(lock) 2. lock.wait(); 5. lock.notify(); 9. consumeResource(); 6.} 10. } 7. Reacquire lock 8. Return from wait() Consumer Producer Thread Thread 166 [PAGE 167] The Simpsons Scenario: SimpsonsTest public class SimpsonsTest { public static void main(String[] args) { CookyJar jar = new CookyJar(); Homer homer = new Homer(jar); Marge marge = new Marge(jar); new Thread(homer).start(); new Thread(marge).start(); } } 167 [PAGE 168] The Simpsons Scenario: Homer public class Homer implements Runnable { CookyJar jar; public Homer(CookyJar jar) { this.jar = jar; } public void eat() { jar.getCooky(\"Homer\"); try { Thread.sleep((int)Math.random() * 1000); } catch (InterruptedException ie) {} } public void run() { for (int i = 1 ; i <= 10 ; i++) eat(); } 168 } [PAGE 169] The Simpsons Scenario: Marge public class Marge implements Runnable { CookyJar jar; public Marge(CookyJar jar) { this.jar = jar; } public void bake(int cookyNumber) { jar.putCooky(\"Marge\", cookyNumber); try { Thread.sleep((int)Math.random() * 500); } catch (InterruptedException ie) {} } public void run() { for (int i = 0 ; i < 10 ; i++) bake(i); } 169 } [PAGE 170] The Simpsons Scenario: CookieJar public class",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_37",
    "text": "CookyJar { private int contents; private boolean available = false; public synchronized void getCooky(String who) { while (!available) { try { wait(); } catch (InterruptedException e) { } } available = false; notifyAll(); System.out.println( who + \" ate cooky \" + contents); } 170 [PAGE 171] The Simpsons Scenario: CookieJar public synchronized void putCooky(String who, int value) { while (available) { try { wait(); } catch (InterruptedException e) { } } contents = value; available = true; System.out.println(who + \" put cooky \" + contents + \" in the jar\"); notifyAll(); } } 171 [PAGE 172] Timers and TimerTask The classes Timer and TimerTask are part of the java.util package Useful for performing a task after a specified delay performing a sequence of tasks at constant time intervals 172 [PAGE 173] Scheduling Timers The schedule method of a timer can get as parameters: Task, time Task, time, period Task, delay Task, delay, period When to What to do At which rate start 173 [PAGE 174] Timer Example import java.util.*; public class CoffeeTask extends TimerTask { public void run() { System.out.println(\u201cTime for a Coffee Break\u201d); } public static void main(String args[]) { Timer timer = new Timer(); long hour = 1000",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_38",
    "text": "* 60 * 60; timer.schedule(new CoffeeTask(), 0, 8 * hour); timer.scheduleAtFixedRate(new CoffeeTask(), new Date(), 24 * hour); } 174 } [PAGE 175] Stopping Timers A Timer thread can be stopped in the following ways: Apply cancel() on the timer Make the thread a daemon Remove all references to the timer after all the TimerTask tasks have finished Call System.exit() 175 [PAGE 176] PACKAGES A java package is a group of similar types of classes, interfaces and sub-packages. Package in java can be categorized in two form, built-in package and user-defined package. There are many built-in packages such as java, lang, awt, javax, swing, net, io, util, sql, etc. Advantages: Java package is used to categorize the classes and interfaces, so that they can be easily maintained. Java package provides access protection. Java package removes naming collision. [PAGE 177] PACKAGES contd... Example: package mypackage; public class Simple { public static void main(String args[]) { System.out.println(\u201cWelcome to my package\u201d); }} Compilation: javac -d.<filename.java> Javac -d . Simple.java Execution: java <package_name> . <file_name> java mypackage . Simple [PAGE 178] PACKAGES contd... Types of Packages: 1. Built-in Packages: In Java packages consist of a large number of classes, interfaces. For example: In java API",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_39",
    "text": "\u2013 lang, io, util, awt, applet, net. 2. User Defined Packages: User created packages. a. A directory so called package. b. Inside this directory, creating related classes and Interfaces for this package name. Accessing Techniques: 1. Using Package Name: import package . *; a. Import all classes b. Import specifig class 2. import package . Classname; 3. fully qualified name [PAGE 179] PACKAGES contd... Creation of User-defined Package: Create a directory and named it \u2013 myPackage Create a class inside this directory \u2013 MyClass // Package creation package myPackage; public class MyClass { public void getNames(String n) System.out.println(n); } } // Class creation Import myPackage . MyClass; Public class MyName { Public static void main(String args[]) { String name = \u201cG. Ganesan\u201d; MyClass c = new MyClass(); // Creating instance of MyClass c.getNames(name); // Passing the argument to the method // in class in package. } } [PAGE 180] PACKAGES contd... Creation of User-defined Package: Create a directory and named it \u2013 myPackage Create a class inside this directory \u2013 MyClass // Package creation package myPackage; public class MyClass { public void getNames(String n) System.out.println(n); } } // Class creation Import myPackage . MyClass; Public class MyName { Public static",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_40",
    "text": "void main(String args[]) { String name = \u201cG. Ganesan\u201d; MyClass c = new MyClass(); // Creating instance of MyClass c.getNames(name); // Passing the argument to the method // in class in package. } } [PAGE 181] Storage Method Directory Structure The package name is closely associated with the directory structure used to store the classes. The classes and its entities belongs to a specific package are stored together in the same directory. Also they are stored in a syb-directory structure specified by its package name. For example: <Base_Directory> . <Sub_Directory> Package: MyPackage Class: MyClass ($BASE_DIR\\com\\gg\\project\\java\\interim\\MyPackage\\ MyClass.class) com.gg.project.java.interim.MyPackage CLASSPATH The base directory located anywhere in the file system. Java compiler and runtime must be informed about the location of the $BASE_DIR to locate the classes. This is accomplished by an environment variable called \u201cCLASSPATH\u201d. Find: PATH, SET PATH, SET CLASSPATH [PAGE 182] Points to Remember 1. Every class is part of some package. 2. If no package is speicified, the classes in the file goes into a speical unnamed package. 3. All classes/interfaces in a file are part of the same package. Multiple files can specify the same package name. 4. If package name is specified, the file must be in",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.2 Java Multithreading_41",
    "text": "a subdirectory called name. (The directory name must match the package name) 5. We can access public classes in another (named) package using import package_name . class_name; QUERIES?",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.2 Java Multithreading.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-3.1 Java Exception Handling.pdf] [PAGE 1] Content 1. Exception Handling 2. Exception Classes 3. try and catch 4. throw and throws 5. Multiple catch Exceptions 6. Annotations [PAGE 2] 1. Exception Handling [PAGE 3] Introduction Exception is an abnormal condition that arises when executing a program. In the language that do not support exception handling, errors must be checked and handled manually, usaually through the use of error codes. * Java provides syntactic mechanisms to signal, detect and handle errors. * Java ensures a clean separation between the code executed in the absence of errors and the code to handle various kinds of errors. * Java brings run-time error management into object- oriented programming. [PAGE 4] Introduction cont... An exception is an object that describes an exceptional condition (error) that has occured when executing a program. Exception handling involves: 1. When an error occurs, an object (exception) representing this error is created and thrown in the method that caused it. 2. That method may choose to handle the exception itself or pass it on. 3. Either way, at some point, the exception is caught and processed. [PAGE 5] Introduction cont... Exception Sources Exceptions can be:",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_1",
    "text": "1. Generated by the Java run-time system Fundamental errors that violate the rules of the Java language or the constraints of the Java execution environment. Ex: IOException, ClassNotFoundException, SQLException, RuntimeException, etc. 2. Manually generated by programmer\u2019s code. This exceptions are typically used to report some error conditions to the caller of a method. [PAGE 6] Need for Exception Handling Java programs are compiled and executed by JVM (Java Virtual Machine). Java compiler translate the statements in a program as like an Interpreter based approach. Suppose if any unexpected error (Exceptional condition) occurs, the execution stopped or terminated. A good programmer understand the statements that may create unexpected error, then that statement included with exception handling. Now all the statements in the program will be executed. [PAGE 7] Need for Exception Handling cont... An exception may occur: * Invalid data as input * File cannot be found or opened. * Network connection may be disturbed in the middle of communications. * JVM may run out of memory. [PAGE 8] Testing of Exception Handling package gg_test; class Arithmetic { public static void main(String[] args) { int a = 0; int b = 12/a; System.out.println(+b); } } When executing the class file Exception",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_2",
    "text": "in thread \"main\" java.lang.ArithmeticException: / by zero at gg_test/gg_test.Arithmetic.main(Arith.java:7) [PAGE 9] Points to Remember Exception: * Exception is an abnormal condition that arises at run time. * Event that disrupts the normal flow of the program. * It is an object which is thrown at run time. Exception Handling: * It is a mechanism to handle runtime errors. * Normal flow of the application can be maintained. * It is an object which is thrown at runtime. * Exception handling done with the exception object. [PAGE 10] System Errors 1. Syntax Errors: Compiler detects the errors, when the rules of the language have not been followed. 2. Runtime Errors: When the program is running under an environment that detects an operation is impossible to carry out. 3. Logic Errors: When the program does not perform the way it was intended to. [PAGE 11] 2. Exception Classes [PAGE 12] Introduction Java exception classes are arranged in a hierarchical manner. Throwable class is the root class in this hierarchy. A programmer can import the root class and use the exception handling technique in their program. The \u201cimport java.lang.Throwable;\u201d statement can provide to all exceptions and errors. Throwable class inherited by two subclasses:",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_3",
    "text": "1. Exception 2. Error [PAGE 13] Exception Types 1. Checked Exceptions (compile / static time): Compiler detects the errors, when the rules of the language have not been followed. Ex: IOException, SQLException. 2. Unchecked Exception (Runtime / Dynamic): The ignored exceptions at the time of compilation. When the program is running under an environment that detects an operation is impossible to carry out. These includes programming bugs (logic error or improper use of an API). Ex: ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException. 3. Errors: Errors are not exceptions, but problems may arise beyond the control of the user or the programmer. Ex: OutOfMemoryError, VirtualMachineError, AssertionError. [PAGE 14] Exception Class Hierarchy [PAGE 15] Exception Class Hierarchy cont... All exceptions are sub-classes of the build-in class \u201cThrowable\u201d. Throwable contains two immediate sub-classes: 1. Exception \u2013 Program should catch exceptional conditions. The Exception class includes: (a) RuntimeException \u2013 Defined automatically for user programs to include: division by zero, invalid array indexing, etc. (b) user defined exception classes 2. Error \u2013 Indicate the error with the run-time environment, when user programs are not supposed to catch them. [PAGE 16] Exception Handling Keywords 1. try \u2013 a block surrounding program statements to monitor for exception. 2. catch \u2013",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_4",
    "text": "together with try, catches specific kinds of exceptions and handles them in some way. 3. finally \u2013 specifies any code that absolutely must be executed whether or not an exception occurs. 4. throw \u2013 used to throw a specific exception from the program 5. throws \u2013 specifies which exceptions a given method can throw. [PAGE 17] Exception Handling Methods Method Description Returns a detailed message about the exception that has occurred. public String getMessage() This message is initialized in the Throwable constructor. public Throwable getCause() Returns the cause of the exception as represented by a Throwable object. Returns the name of the class concatenated with the result of public String toString() getMessage(). Prints the result of toString() along with the stack trace to System.err, the public void printStackTrace() error output stream. public StackTraceElement [] Returns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last getStackTrace() element in the array represents the method at the bottom of the call stack. public Throwable Fills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace. fillInStackTrace() [PAGE",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_5",
    "text": "18] 3. try and catch [PAGE 19] Introduction try \u2013 a block surrounding program statements to monitor for exception. Syntax: try { // block of code to monitor for errors // the code you think can raise an exception } catch(ExceptionType <exception_object>) { // exception handler for ExceptionType } finally // optional { // block of code to be executed after try block ends. } [PAGE 20] Implementation A method catches an exception using a combination of try and catch keywords. The program code that may generate an exception should be placed inside the try-catch block. The program code which is prone to exception is placed in the try block. When an error occurs, that exception is handled by catch block associated with it. Every try block should be immediately followed either by a catch block or finally block. [PAGE 21] Implementation cont... A catch statement involves declaring the type of exception that might be tried to catch. If an error occurs, the catch block follow the try block is checked. If the type of exception that occurred is listed in a catch block. The exception is passed to the catch block similar to an argument that is passed into",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_6",
    "text": "a method parameter. [PAGE 22] Implementation cont... package gg_test; class Arithmetic { public static void main(String[] args) { int a = 0; int b = 12/a; System.out.println(+b); } } When executing the class file Exception in thread \"main\" java.lang.ArithmeticException: / by zero at gg_test/gg_test.Arithmetic.main(Arith.java:7) [PAGE 23] Implementation cont... package gg_test; class Arithmetic { public static void main(String[] args) { try { int a = 0; int b = 12/a; // control moves to immediate catch block System.out.println(+b); } catch (ArithmeticException e) { System.out.println(\u201cDivision by Zero\u201d); } // The exception is handled and the execution resumes int b = 12/a; System.out.println(+b); } } [PAGE 24] Implementation cont... The purpose of catch should be to resolve the exception and then continue as if the error had never happened. try-catch inside a loop: catch (ArithmeticException e) { import java.util.Random; System.out.println(\u201cDivision by zero\u201d); a=0; // set a=0 and contine class HandleError { } public static void main(String args[]) {System.out.println(\u201ca=\u201d +a); int a=0, b=0, c=0; } Random r = new Random(); } for(int i=0; i<32000; i++) { } try { b=r.nextInt(); c=r.nextInt(); a=12345 / (b/c); } [PAGE 25] Implementation cont... Output: Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3 Out of the block [PAGE 26] Implementation cont... class MultiCatch",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_7",
    "text": "{ Java SE 7 and after public static void main(String args[]) { try { int array[] = new int[10]; // Array Index 0 to 9 array[10] = 50 / 0; } catch(ArithmeticException e) { System.out.println(e.getMessage()); } catch(ArrayIndexOutOfBoundsException b) { System.out.println(b.getMessage()); } The associativity of the } } assignment operator \u201c=\u201d is Output: right to left. / by zero Therefore, ArithmeticException is thrown first. [PAGE 27] Implementation cont... class MultiCatch { public static void main(String args[]) { try { int array[] = new int[10]; // Array Index 0 to 9 array[10] = 50 / 0; } catch(ArithmeticException | ArrayIndexOutOfBoundsException e) { System.out.println(e.getMessage()); } 1. Reduce the code duplication } 2. Increases the efficiency. } 3. If a catch block handles Output: multiple exceptions, the catch / by zero parameter is implicitly final. It means we cannot assign any values to catch parameters. [PAGE 28] Implementation cont... class MultiCatch { public static void main(String args[]) { try { int array[] = new int[10]; // Array Index 0 to 9 array[10] = 50 / 0; } catch(Exception e) { System.out.println(e.getMessage()); } * If multiple exception in a single catch block, the rule is generalized } to specialized. Then there is a } Output:",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_8",
    "text": "hierarchy of exception. / by zero * We can catch the \u201cbase exception\u201d only instead of catching multiple specialized exceptions. [PAGE 29] Implementation cont... class MultiCatch { public static void main(String args[]) { try { int array[] = new int[10]; // Array Index 0 to 9 array[10] = 50 / 0; } catch(Exception | ArithmeticException | ArrayIndexOutOfBoundsException e) { System.out.println(e.getMessage()); } ArithmeticException and ArrayIndexOutOfBoundsException } are subclasses of Exception class. } Output: MultiCatch.java:7: error: Alternatives in a multi-catch statement cannot be related by subclassing [PAGE 30] 4. throw and throws [PAGE 31] Introduction User program may throw an exception explicitly; throw ThrowableInstance; ThrowableInstance must be an object of type Throwable or its subclass. Once an exception is thrown by the above exception statement 1. the flow of control stops immediately. 2. the nearest enclosing \u201ctry\u201d statement is inspected if it has a \u201ccatch\u201d statement that matches the type of exception: a. If one exists, control is transferred to that statement b. Otherwise, the next enclosing \u201ctry\u201d statement is examined. c. If no enclosing \u201ctry\u201d statement has a corresponding \u201ccatch\u201d c;ause, the default exception handler halts the program and prints the stack. [PAGE 32] Introduction Two ways to obtain a Throwable",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_9",
    "text": "instance: 1. Creating one with the \u201cnew\u201d operator All java built-in exception have at least two constructors: One without parameters and another with one String parameter. throw new NullPointerException(\u201cdemo\u201d); 2. using a parameter of the \u201ccatch\u201d clause try { . . . } catch(Throwable e) { . . . e . . . [PAGE 33] throw output: class ThrowDemo { Caught inside demoproc. static void demoproc() { Recaught: java.lang.NullPointerException: demo try { throw new NullPointerException(\"demo\"); } catch(NullPointerException e) { System.out.println(\"Caught inside demoproc.\"); throw e; // rethrow the exception } } public static void main(String args[]) { try { demoproc(); } catch(NullPointerException e) { System.out.println(\"Recaught: \" + e); } } } [PAGE 34] throw The program gets two chances to deal with the same error. First, main( ) sets up an exception context and then calls demoproc( ). The demoproc( ) method then sets up another exception-handling context and immediately throws a new instance of NullPointerException, which is caught on the next line. The exception is then re-thrown. [PAGE 35] throws A throws clause lists the types of exceptions that a method might throw. All other exceptions that a method can throw must be declared in the throws clause. If they",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_10",
    "text": "are not, a compile-time error will result. Type method-name(parameter-list) throws exception-list { // body of method } Here, exception-list is a comma-separated list of the exceptions that a method can throw. [PAGE 36] throws // This program contains an error and will not compile. class ThrowsDemo { static void throwOne() { System.out.println(\"Inside throwOne.\"); throw new IllegalAccessException(\"demo\"); } public static void main(String args[]) { throwOne(); } } [PAGE 37] throws // This is now correct class ThrowsDemo { static void throwOne() throws IllegalAccessException { System.out.println(\"Inside throwOne.\"); throw new IllegalAccessException(\"demo\"); } public static void main(String args[]) { try { Output: throwOne(); inside throwOne caught java.lang.IllegalAccessException: demo } catch (IllegalAccessException e) { System.out.println(\"Caught \" + e); } }} [PAGE 38] User Defined Exception To create your own exception types to handle situations specific to your applications. Define a subclass of Exception, subclasses don\u2019t need to actually implement anything. class MyException extends Exception { . . . } The Exception class does not define any methods of its own. It inherit those methods provided by Throwable [PAGE 39] Throwable class Methods Throwable fillInStackTrace() - returns a Throwable object that contains a completed stack trace; the object can be rethrown. Throwable getCause() - returns the",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_11",
    "text": "exception that underlines the current exception. If no underlying exception exists, null is returned. String getLocalizedMessage() - returns a localized description of the exception. String getMessage() - returns a description of the exception. StackTraceElement[] getStackTrace() - returns an array that contains the stack trace; the method at the top is the last one called before exception. [PAGE 40] Throwable class Methods Throwable initCause(Throwable causeExc) \u2013 associates causeExc with the invoking exception as its cause, returns the exception reference. void printStackTrace() - displays the stack trace void printStackTrace(PrintStream stream) \u2013 sends the stack trace to the specified stream. void printStackTrace(PrintWriter stream) void setStackTrace(StackTraceElement elements[ ]) - sets the stack trace to the elements passed in elements; for specialized applications only. String toString() - returns a String object containing a description of the exception; called by print() when displaying a Throwable object. [PAGE 41] Creating User Defined Exception In order to create custom exception, we need to extend Exception class that belongs to java.lang package. Consider the following example, where we create a custom exception named WrongFileNameException: public class WrongFileNameException extends Exception { public WrongFileNameException(String errorMessage) { super(errorMessage); } } Example 1: Let's see a simple example of Java custom exception. In",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_12",
    "text": "the following code, constructor of InvalidAgeException takes a string as an argument. This string is passed to constructor of parent class Exception using the super() method. Also the constructor of Exception class can be called without using a parameter and calling super() method is not mandatory. [PAGE 42] Creating User Defined Exception else { // class representing custom exception System.out.println(\"welcometovote\"); class InvalidAgeException extends Exception } { } public InvalidAgeException (String str) { \u2022 //mainmethod // calling the constructor of parent Exception \u2022 public static void main(Stringargs[]) super(str); \u2022 { try } } { //callingthemethod // class that uses custom exception InvalidAgeException validate(13); public class TestCustomException1 } { catch (InvalidAgeExceptionex) { // method to check the age \u2022 System.out.println(\"Caughttheexception\"); static void validate (int age) throws InvalidAgeExcep\u2022tion{ if(age < 18){ \u2022 //printingthemessagefromInvalidAgeExceptionobject System.out.println(\"Exceptionoccured:\"+ex); } // throw an object of user defined exception throw new InvalidAgeException(\"age is not valid to vote\"); System.out.println(\"restofthecode...\"); } } } [PAGE 43] Creating User Defined Exception class ExceptionDemo { static void compute (int a) throws MyException{ System.out.println(\u201cCalled compute(\u201c+a+\u201d)\u201d); if(a > 10) throw new MyException(a); System.out.println(\u201cNormal exit\u201d); } } The static compute method throws the MyException exception whenever its \u2018a\u2019 argument is greater than 10. [PAGE 44] Creating User",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_13",
    "text": "Defined Exception The main method calls compute with two arguments within a try block that catches the MyException exception. public static void main(String args[]) { try { compute(1); compute(20); } catch(MyException e) { System.out.println(\u201ccaught \u201c +e); } }// end of main [PAGE 45] Chained Exceptions The chained exception allows to associate with a given exception another exception that describes its cause. Throwable class includes two constructors to handle chained exceptions: 1. Throwable (Throwable causeExc) 2. Throwable (String msg, Throwable causeExc) Both constructor create an exception with \u201ccauseExc\u201d being its underlying reason and optional \u201cmsg\u201d providing the textual description. [PAGE 46] Chained Exceptions Throwable class also include two methods to handle chained exceptions: 1. Throwable getCause() - returns an exception that is the cause of the current exception, or null if there is no underlying exception. 2. Throwable initCause(Throwable causeExc) \u2013 associates \u201ccauseExc\u201d with the invoking exception and returns a reference to the exception. a. InitCause - allows to associate a cause with an existing exception. b. The cause exception can be set only once. c. If the cause exception was set by a constructor, it is not possible to set it again with initCause. [PAGE 47] Chained Exceptions - Example-1",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_14",
    "text": "class ChainExcDemo { /* The demoprocess method creates a new \u201cNullPointerException\u201d exception \u201ce\u201d, associates \u201cArithmeticException\u201d as its cause, then throws \u201ce\u201d. */ static void demoprocess() { NullPointerException e = new NullPointerException(\u201ctop layer\u201d); e.initCause(new ArithmeticException(\u201ccause\u201d)); throw e; } [PAGE 48] Chained Exceptions - Example-2 The \u201cmain\u201d method calls the method \u201cdemoprocess\u201d within the \u201ctry\u201d block that catches \u201cNullPointerException\u201d, then displays the exception and its cause. public static void main(String args[]) { try { demoprocess(); } catch(NullPointerException e) { System.out.println(\u201cCaught: \u201c +e); System.out.println(\u201cCause: \u201c +e.getCause()); } } // end of main } // end of class A cause exception may iteself have a cause. In fact, the cause-chain of exception may be arbitrarily long [PAGE 49] Exception Handling - Exercise-1 Step-1: Create exception classes \u201cEven\u201d and \u201cOdd\u201d. Step-2: Generate numbers within an endless loop. Print the generated numbers. Step-3: If the number is even, throw the Even exception with the message \u201cThe number thrown an even number\u201d along with the number. Step-4: If the number is odd, throw the Odd exception with the message \u201cThe number thrown an odd number\u201d along with the number. Step-5: Catch the Even exception within the endless loop and print the message. Step-6: Catch the Odd exception",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_15",
    "text": "outside of the loop and print the message. [PAGE 50] Annotations [PAGE 51] Introduction Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. Annotations provide additional information about the program to the compiler, and do not affect the execution of the compiled program. Annotations start with @ symbol. Syntax: @AnnotationName [PAGE 52] Usage Annotations have a number of uses. Information for the Compiler: Annotations can be used by the compiler to detect errors or suppress warnings. Compile-time and Deployment-time Processing: Software tools can process annotation information to generate code, XML files, and so forth. Runtime Processing: Some annotations are available to be examined at runtime. Note: Find the annotation types are available in the Java Platform, Standard Edition (Java SE API), [PAGE 53] Types of Annotation Annotations enable Java code to be analyzed better and provide even stronger type checks. 1. Predefined Annotations 2. Meta-annotations a. @Deprecated a. @Retention b. @Override b. @Documented c. @SuppressWarnings c. @Target d. @SafeVarargs d. @Inherited e. @FunctionalInterface e. @Repeatable [PAGE 54] Annotation - Example Java annotations can be placed above class, method,",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-3.1 Java Exception Handling_16",
    "text": "interface, fields, and other element declarations. @Override - When a method overriding. Not mandatory, if use it, the compiler gives an error if something is wrong while overriding. Parameter type @SuppressWarnings class WordProcess { @SuppressWarnings(\u201cunchecked\u201d) Static void wordsList() { ArrayList wordList = new ArrayList<>(); // This cause an unchecked warning WordList.add(\u201cProgram\u201d); System.out.println(Word List =>\u201d +wordList); }",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-3.1 Java Exception Handling.txt"
    }
  },
  {
    "id": "Unit-5.2  JPA Architecture_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-5.2 JPA Architecture.pdf] [PAGE 1] CSE 2006 - Programming in Java Course Type: LP Credits: 3 [PAGE 2] Unit- 5 Database Applications With JDBC Defining the layout of the JDBC API - Connecting to a database by using a JDBC driver \u2013 Submitting queries and getting results from the database - Specifying JDBC driver information externally. Java Persistence API JPA architecture, ORM Components, - Performing CRUD operations using the JDBC API. JPA installation, Java Persistence Query language, Creating JPA entities, Advanced mappings. 2 [PAGE 3] Java Persistence API What is JPA? Spring Boot JPA is a Java specification for managing relational data in Java applications. It allows us to access and persist data between Java object/ class and relational database. JPA follows Object-Relation Mapping (ORM). It is a set of interfaces. It also provides a runtime Entity Manager API for processing queries and transactions on the objects against the database. It uses a platform-independent object-oriented query language JPQL (Java Persistent Query Language). In the context of persistence, it covers three areas: The Java Persistence API Object-Relational metadata The API itself, defined in the persistence package JPA is not a framework. It defines a concept that",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.2  JPA Architecture.txt"
    }
  },
  {
    "id": "Unit-5.2  JPA Architecture_1",
    "text": "can be implemented by any framework. 3 [PAGE 4] Java Persistence API Why should we use JPA? JPA is simpler, cleaner, and less labor-intensive than JDBC, SQL, and hand-written mapping. JPA is suitable for non-performance oriented complex applications. The main advantage of JPA over JDBC is that, in JPA, data is represented by objects and classes while in JDBC data is represented by tables and records. It uses POJO(Plain Old Java Object) to represent persistent data that simplifies database programming. There are some other advantages of JPA: 1. JPA avoids writing DDL in a database-specific dialect of SQL. Instead of this, it allows mapping in XML or using Java annotations. 2. JPA allows us to avoid writing DML in the database-specific dialect of SQL. 3. JPA allows us to save and load Java objects and graphs without any DML language at all. 4. When we need to perform queries JPQL, it allows us to express the queries in terms of Java entities rather than the (native) SQL table and columns. 4 [PAGE 5] Java Persistence API JPA Features There are following features of JPA: It is a powerful repository and custom object-mapping abstraction. It supports for cross-store persistence. It means",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.2  JPA Architecture.txt"
    }
  },
  {
    "id": "Unit-5.2  JPA Architecture_2",
    "text": "an entity can be partially stored in MySQL and Neo4j (Graph Database Management System). It dynamically generates queries from queries methods name The domain base classes provide basic properties It supports transparent auditing Possibility to integrate custom repository code It is easy to integrate with Spring Framework with the custom namespace 5 [PAGE 6] JPA Architecture JPA is a source to store business entities as relational entities. It shows how to define a POJO as an entity and how to manage entities with relation. The following figure describes the class-level architecture of JPA that describes the core classes and interfaces of JPA that is defined in the javax persistence package. The JPA architecture contains the following units: Persistence: It is a class that contains static methods to obtain an EntityManagerFactory instance. EntityManagerFactory: It is a factory class of EntityManager. It creates and manages multiple instances of EntityManager. EntityManager: It is an interface. It controls the persistence operations on objects. It works for the Query instance. Entity: The entities are the persistence objects stores as a record in the database. Persistence Unit: It defines a set of all entity classes. In an application, EntityManager instances manage it. The set of entity",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.2  JPA Architecture.txt"
    }
  },
  {
    "id": "Unit-5.2  JPA Architecture_3",
    "text": "classes represents the data contained within a single data store. 6 [PAGE 7] JPA Architecture EntityTransaction: It has a one-to-one relationship with the EntityManager class. For each EntityManager, operations are maintained by EntityTransaction class. Query: It is an interface that is implemented by each JPA vendor to obtain relation objects that meet the criteria. 7 [PAGE 8] JPA Implementations JPA is an open-source API. There is various enterprises vendor such as Eclipse, RedHat, Oracle, etc. that provides new products by adding the JPA in them. There are some popular JPA implementations frameworks such as Hibernate, EclipseLink, DataNucleus, etc. It is also known as Object-Relation Mapping (ORM) tool. Object-Relation Mapping (ORM) In ORM, the mapping of Java objects to database tables, and vice-versa is called Object-Relational Mapping. The ORM mapping works as a bridge between a relational database (tables and records) and Java application (classes and objects). In the following figure, the ORM layer is an adapter layer. It adapts the language of object graphs to the language of SQL and relation tables. 8 [PAGE 9] Object-Relation Mapping (ORM) The ORM layer exists between the application and the database. It converts the Java classes and objects so that they can be",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.2  JPA Architecture.txt"
    }
  },
  {
    "id": "Unit-5.2  JPA Architecture_4",
    "text": "stored and managed in a relational database. By default, the name that persists become the name of the table, and fields become columns. Once an application sets-up, each table row corresponds to an object. 9 [PAGE 10] CRUD operations The CRUD stands for Create, Read/Retrieve, Update, and Delete. These are the four basic functions of the persistence storage. The CRUD operation can be defined as user interface conventions that allow view, search, and modify information through computer-based forms and reports. CRUD is data-oriented and the standardized use of HTTP action verbs. HTTP has a few important verbs. POST: Creates a new resource GET: Reads a resource PUT: Updates an existing resource DELETE: Deletes a resource Within a database, each of these operations maps directly to a series of commands. However, their relationship with a RESTful API is slightly more complex. 10 [PAGE 11] CRUD operations Standard CRUD Operation CREATE Operation: It performs the INSERT statement to create a new record. READ Operation: It reads table records based on the input parameter. UPDATE Operation: It executes an update statement on the table. It is based on the input parameter. DELETE Operation: It deletes a specified row in the table. It is",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.2  JPA Architecture.txt"
    }
  },
  {
    "id": "Unit-5.2  JPA Architecture_5",
    "text": "also based on the input parameter. How CRUD Operations Works CRUD operations are at the foundation of the most dynamic websites. Therefore, we should differentiate CRUD from the HTTP action verbs. 11 [PAGE 12] CRUD operations RESTful Web Operation SQL HTTP verbs Service Create INSERT PUT/POST POST Read SELECT GET GET Update UPDATE PUT/POST/PATCH PUT Delete DELETE DELETE DELETE 12 [PAGE 13] More on JDBC More on JDBC https://www.javatpoint.com/java-jdbc MS access with JDBC connection https://www.c-sharpcorner.com/UploadFile/433c33/jdbc-con nection-to-ms-access/ Performing CRUD operations using the JDBC API https://www.javaguides.net/2020/02/java-jdbc-crud-operatio ns-in-eclipse.html 13",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-5.2  JPA Architecture.txt"
    }
  },
  {
    "id": "1.1_0",
    "text": "TOPIC: [UNIT: Unit1_Basics] Definition: [SOURCE_FILE: 1.1.pptx] Course Objectives Students who complete this course will be able to Analyze the Java flow control using essentials of Java programming. Solve simple business problems using an object-oriented approach. Demonstrate synchronization among different processes using a multithreading approach and exception handling techniques. Implement Java Input and Output streaming using Java packages. Develop and create real-time applications using JDBC and JPA technology. Unit-1 Contents Java Introduction Java Hello World, Java JVM, JRE and JDK, Difference between C & C++, Java Variables, Java Data Types, Java Operators, Java Input and Output, Java Expressions & Blocks, Java Comment Java Flow Control Java if...else, Java switch Statement, Java for Loop, Java for-each Loop, Java while Loop, Java break Statement, Java continue Statement Introduction to JAVA The primary objective of Java programming language creation was to make it portable, simple and secure programming language. The features of Java are also known as Java buzzwords. A list of the most important features of the Java language is, Simple Object-Oriented Portable Platform independent Secured Robust Architecture neutral Interpreted High Performance Multithreaded Distributed Dynamic Features of JAVA Simple: Sun Microsystem expressed the JAVA is simple comparing C++ based on Syntax (same as",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.1_1",
    "text": "C++) Complexity \u2013 explicit pointers, Overloading, etc. Destructor \u2013 Deleting Unreferenced objects in C++ (Garbage Collection) Object-oriented: - Software consists of Object, Class, Inheritance, Polymorphism, Encapsulation, Abstraction. Machine/Platform Independent: Write and Compile in one machine can Run in any machine using JVM. Features of JAVA contd... Machine/Platform Independent: Write and Compile in one machine can Run in any machine using JVM. Java code can be executed on multiple platforms, for example, Windows, Linux, Sun Solaris, Mac/OS, etc. Java code is compiled by the compiler and converted into bytecode. This bytecode is a platform-independent code because it can be run on multiple platforms, i.e., Write Once and Run Anywhere (WORA). Features of JAVA contd... Features of JAVA contd... Features of JAVA contd... Secured: Class Loader: Classloader in Java is a part of the Java Runtime Environment (JRE) which is used to load Java classes into the Java Virtual Machine dynamically. It adds security by separating the package for the classes of the local file system from those that are imported from network sources. Byte code Verifier: It checks the code fragments for illegal code that can violate access rights to objects. Security Manager: It determines what resources a class can access",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.1_2",
    "text": "such as reading and writing to the local disk. Java language provides these securities by default. Some security can also be provided by an application developer explicitly through SSL, JAAS, Cryptography, etc. Features of JAVA contd... Robust: the Java It uses strong memory management. There is a lack of pointers that avoids security problems. Java provides automatic garbage collection which runs on Virtual Machine to get rid of objects which are not being used by a Java application anymore. Exception handling and the Type checking mechanism. Architecture Neutral: The size of primitive data types are fixed. C++ - 32-bit occupies \u2013 2 bytes and 64-bit occupies \u2013 4 bytes. Java \u2013 4-bytes for 32 and 64 bit. Portable: Carrying bytecode to run on any kind of machine. Features of JAVA contd... High Performance: Java is faster than other traditional interpreted programming languages because Java bytecode is close to native code. It is still a little bit slower than a compiled language (e.g., C++). Java is an interpreted language that is why it is slower than compiled languages, e.g., C, C++, etc. Distributed: Java is distributed because it facilitates users to create distributed applications in Java. RMI and EJB are used",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.1_3",
    "text": "for creating distributed applications. It helps us to access files by calling the methods from any machine on the internet. Features of JAVA contd... Multi-threaded A thread is like a separate program, executing concurrently. We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it doesn't occupy memory for each thread. It shares a common memory area. Threads are important for multi-media, Web applications, etc. Dynamic: Java is a dynamic language. It supports the dynamic loading of classes. It means classes are loaded on demand. It also supports functions from its native languages, i.e., C and C++. Java supports dynamic compilation and automatic memory management (garbage collection). JAVA Editions Java has 4 types of editions 1. Java Platform, Standard Edition (Java SE) 2. Java Platform, Enterprise Edition (Java EE) 3. Java Platform, Micro Edition (Java ME) 4. Java FX Java SE It defines everything from the basic types and objects of the Java programming language to high-level classes that are used for networking, security, database access, graphical user interface (GUI) development, and XML parsing. In addition to the core API, the Java SE platform consists of a",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.1_4",
    "text": "virtual machine, development tools, deployment technologies, and other class libraries and toolkits commonly used in Java technology applications. JAVA Editions JAVA Editions Java EE The Java EE platform is built on top of the Java SE platform. The Java EE platform provides an API and runtime environment for developing and running large-scale, multi-tiered, scalable, reliable, and secure network applications. Java ME The Java ME platform provides an API and a small-footprint virtual machine for running Java programming language applications on small devices, like mobile phones. The API is a subset of the Java SE API, along with special class libraries useful for small device application development. Java ME applications are often clients of Java EE platform services. Java FX Java FX technology is a platform for creating rich internet applications written in Java FX ScriptTM. Java FX Script is a statically-typed declarative language that is compiled to Java technology bytecode, which can then be run on a Java VM. Applications written for the Java FX platform can include and link to Java programming language classes, and may be clients of Java EE platform services. Implementation of Simple Program JAVA Programming Whenever, a program is written in JAVA, the javac compiles",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.1_5",
    "text": "it. The result of the JAVA compiler is the \u201c.class\u201d called Bytecode and not the machine native code (unlike C compiler). The bytecode generated is a non-executable code and needs an interpreter to execute on a machine. This interpreter is the JVM and thus the Bytecode is executed by the JVM. And finally program runs by \u201cjava\u201d to give the desired output. JAVA Programming contd... Java Development Kit (JDK) is a software development environment used for developing Java applications and applets. It includes the Java Runtime Environment (JRE), an interpreter/loader (Java), a compiler (javac), an archiver (jar), a documentation generator (Javadoc), and other tools needed in Java development. Java Runtime Environment (JRE) is a Runtime Environment that provides the minimum requirements for executing a Java application. It consists of the Java Virtual Machine (JVM), core classes, and supporting files. Java Virtual Machine (JVM) A specification where the working of Java Virtual Machine is specified. But implementation provider is independent to choose the algorithm. Its implementation has been provided by Sun and other companies. An implementation is a computer program that meets the requirements of the JVM specification. Runtime Instance Whenever you write a java command on the command prompt to",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.1_6",
    "text": "run the java class, an instance of JVM is created. JAVA Programming contd... Components of JRE Deployment Technologies: Java Web Start, and Java Plug-in. User Interface Toolkits: Abstract Window Toolkit (AWT), Swing, Java 2D, Accessibility, Image I/O, Print Service, Sound, drag, and drop (DnD), and input methods. Integration Libraries: Interface Definition Language (IDL), Java Database Connectivity (JDBC), Java Naming and Directory Interface (JNDI), Remote Method Invocation (RMI), Remote Method Invocation Over Internet Inter-Orb Protocol (RMI-IIOP), and scripting. Other base Libraries: International support, input/output (I/O), extension mechanism, Beans, Java Management Extensions (JMX), Java Native Interface (JNI), Math, Networking, Override Mechanism, Security, Serialization, and Java for XML Processing (XML JAXP). Lang and util base Libraries: lang and util, management, versioning, zip, instrument, reflection, Collections, Concurrency Utilities, Java Archive (JAR), Logging, Preferences API, Ref Objects, and Regular Expressions. Java Virtual Machine (JVM), including Java HotSpot Client and Server Virtual Machines. JAVA Programming contd... Declaration Constraints File Name must be a Class Name. Extension is .java Class Name must be an Noun. First letter must be a capital alphabet. More than one words are combined by underscore. Method Name should be Variable with Noun. JAVA Programming contd... System Requirements: Set path up to binary",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.1_7",
    "text": "directory. - Install jdk (version is dependable with application) JAVA Programming contd... Structure in Java: \u2212 // Single line. /* Multiple Line */ package com.vitbhopal.scse import java.util.Scanner; interface cube { } class Cube { } public static void main(String args[]) { } JAVA Programming contd... Simple Program: File name \u201cHello.java\u201d class Hello { public static void main(String a[]) { System.out.println(\u201cHello VITans\u201d); } Compilation: $ javac Hello.java Compilation creates \u201cHello.class\u201d file. Execution: $ java Hello JAVA Programming contd... Parameters Used in Hello Program class keyword is used to declare a class in Java. public keyword is an access modifier that represents visibility. It means it is visible to all. static is a keyword. If we declare any method as static, it is known as the static method. The core advantage of the static method is that there is no need to create an object to invoke the static method. The main() method is executed by the JVM, so it doesn't require creating an object to invoke the main() method. So, it saves memory. Void: Return type of the method. void doesn't return any value. main: Starting point of the compilation and execution of the program. String[] args or String args[] is",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.1_8",
    "text": "used for command line argument. System.out.println() is used to print statement. Here, System is a class, out is an object of the PrintStream class, println() is a method of the PrintStream class.",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.1.txt"
    }
  },
  {
    "id": "1.3_0",
    "text": "TOPIC: [UNIT: Unit1_Basics] Definition: [SOURCE_FILE: 1.3.pptx] If and If-else Statements Switch Statement For, For-each Statements While and do-while Statements Break and Continue Statements Array Content Flow of Control Java executes one statement after the other in the order they are written Many Java statements are flow control statements: Alternation: if, if else, switch Looping: Escapes: for, while, do while break, continue, return If \u2013 The Conditional Statement The if statement evaluates an expression and if that evaluation is true then the specified action is taken if ( x < 10 ) x = 10; If the value of x is less than 10, make x equal to 10 It could have been written: if ( x < 10 ) x = 10; Or, alternatively: if ( x < 10 ) { x = 10; } If\u2026 else Statement The if \u2026 else statement evaluates an expression and performs one action if that evaluation is true or a different action if it is false. if (x != oldx) { System.out.print(\u201cx was changed\u201d); } else { System.out.print(\u201cx is unchanged\u201d); } Nested if \u2026 else if ( myVal > 100 ) { if ( remainderOn == true) { myVal = mVal % 100;",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.3.txt"
    }
  },
  {
    "id": "1.3_1",
    "text": "} else { myVal = myVal / 100.0; } } else { System.out.print(\u201cmyVal is in range\u201d); } else if Useful for choosing between alternatives: } else { // if all previous tests have failed, execute code block #3 } The switch Statement switch ( n ) { case 1: // execute code block #1 break; break; default: // if all previous tests fail then //execute code block #4 break; } The for loop Loop n times for ( i = 0; i < n; i++ ) { // this code body will execute n times // ifrom 0 to n-1 } Nested for: for ( j = 0; j < 10; j++ ) { for ( i = 0; i < 20; i++ ){ // this code body will execute 200 times } } while loops while(response == 1) { System.out.print( \u201cID =\u201d + userID[n]); n++; response = readInt( \u201cEnter \u201c); } do {\u2026 } while loops do { System.out.print( \u201cID =\u201d + userID[n] ); n++; response = readInt( \u201cEnter \u201d ); }while (response == 1); Break A break statement causes an exit from the innermost containing while, do, for or switch statement. for ( int i = 0; i",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.3.txt"
    }
  },
  {
    "id": "1.3_2",
    "text": "< maxID, i++ ) { if ( userID[i] == targetID ) { index = i; break; } } // program jumps here after break Continue Can only be used with while, do or for. The continue statement causes the innermost loop to start the next iteration immediately for ( int i = 0; i < maxID; i++ ) { if ( userID[i] != -1 ) continue; System.out.print( \u201cUserID \u201d + i + \u201c :\u201d + userID); } Arrays myArray has room for 8 elements the elements are accessed by their index in Java, array indices start at 0 An array is a collection of similar items An array has a fixed: name type length These must be declared when the array is created. Arrays sizes cannot be changed during the execution of the code myArray = 0 1 2 3 4 5 6 7 Declaring Arrays int myArray[]; declares myArray to be an array of integers myArray = new int[8]; sets up 8 integer-sized spaces in memory, labelled myArray[0] to myArray[7] int myArray[] = new int[8]; combines the two statements in one line Assigning Values refer to the array elements by index to store values in them. myArray[0] = 3;",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.3.txt"
    }
  },
  {
    "id": "1.3_3",
    "text": "myArray[1] = 6; myArray[2] = 3; ... can create and initialise in one step: int myArray[] = {3, 6, 3, 1, 6, 3, 4, 1}; Iterating Through Arrays for loops are useful when dealing with arrays: for (int i = 0; i < myArray.length; i++) { myArray[i] = getsomevalue(); } Multi Dimensional Array Two dimensional array: data_type[][] array_name = new data_type[x][y]; For example: int[][] arr = new int[10][20]; or Int arr[][]= new int[10][20]; Three dimensional array: int[][][] threeD_arr = new int[10][20][30]; Declaring the Array 1. Declare the array private Student studentList[]; this declares studentList 2 .Create the array studentList = new Student[10]; this sets up 10 spaces in memory that can hold references to Student objects 3. Create Student objects and add them to the array: studentList[0] = new Student(\"Cathy\", \"Computing\");",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.3.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-4.2 Collections Framework.pdf] [PAGE 1] CSE 2006 - Programming in Java Course Type: LP Credits: 3 Prepared by C.S Rajpoot School of Computing Science and Engineering VIT Bhopal University [PAGE 2] Unit- 4 Java List & I/O Streams String classes, methods, operations on Strings and 1-D Arrays, 2-D and \u25aa Jagged Arrays and its operations Java Collections Framework: Java Collection Interface, Java List Interface, \u25aa Java Array List, Java Vector, Java Stack. Streams: Introduction to Byte-oriented and Character-oriented streams, \u25aa Java I/O Streams, and Java Reader/Writer 2 [PAGE 3] Collections Framework The java.util package contains one of Java\u2019s most powerful \u25aa subsystems: collections A collection is a group of objects. The addition of collections \u25aa caused fundamental alterations in the structure and architecture of many elements in java.util package. collections, java.util contains a wide assortment of classes and \u25aa interfaces that support a broad range of functionality. 3 [PAGE 4] Collections Framework 4 [PAGE 5] The java.util classes are listed here. 5 [PAGE 6] java.util defines the following interfaces 6 [PAGE 7] Collections Overview Java collections framework standardizes the way in which groups of objects are \u25aa handled by your programs. First, the framework had",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_1",
    "text": "to be high-performance. The implementations for the \u25aa fundamental collections (dynamic arrays, linked lists, trees, and hash tables) are highly efficient. Second, the framework had to allow different types of collections to work in a similar \u25aa manner and with a high degree of interoperability Third, extending and/or adapting a collection had to be easy (such as LinkedList, \u25aa HashSet, and TreeSet) Finally, mechanisms were added that allow the integration of standard arrays into \u25aa the collections framework 7 [PAGE 8] The Collection Interfaces The collections framework defines several interfaces. \u25aa Interface Description Collection Enables you to work with groups of objects; it is at the top of the collections hierarchy List Extends Collection to handle sequences (lists of objects) Set Extends Collection to handle sets, which must contain unique elements SortedSet Extends Set to handle sorted sets 8 [PAGE 9] Methods Defined by Collection Method Description Adds obj to the invoking collection. Returns true if obj was added to the collection. boolean add(Object obj) Returns false if obj is already a member of the collection, or if the collection does not allow duplicates. boolean addAll Adds all the elements of c to the invoking collection. Returns true if the",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_2",
    "text": "operation (Collection c) succeeded (i.e., the elements were added). Otherwise, returns false. void clear( ) Removes all elements from the invoking collection. boolean containsAll Returns true if the invoking collection contains all elements of c. Otherwise, returns false. (Collection c) boolean isEmpty( ) Returns true if the invoking collection is empty. Otherwise, returns false. Iterator iterator( ) Returns an iterator for the invoking collection. boolean retainAll Removes all elements from the invoking collection except those in c. Returns true if the (Collection c) collection changed (i.e., elements were removed). Otherwise, returns false. int size( ) Returns the number of elements held in the invoking collection. Object[ ] toArray( ) Returns an array that contains all the elements stored in the invoking collection. 9 [PAGE 10] The List Interface Method Description Inserts obj into the invoking list at the index passed in index. Any preexisting elements at or void add(int index, Object obj) beyond the point of insertion are shifted up. Thus, no elements are overwritten. boolean addAll(int index, Inserts all elements of c into the invoking list at the index passed in index. Any preexisting Collection c) elements at or beyond the point of insertion are shifted up. Object get(int",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_3",
    "text": "index) Returns the object stored at the specified index within the invoking collection. Returns the index of the first instance of obj in the invoking list. If obj is not an element of the int indexOf(Object obj) list, \u20131 is returned. ListIterator listIterator( ) Returns an iterator to the start of the invoking list. ListIterator listIterator(int Returns an iterator to the invoking list that begins at the specified index. index) Removes the element at position index from the invoking list and returns the deleted Object remove(int index) element. The resulting list is compacted. Object set(int index, Object Assigns obj to the location specified by index within the invoking list. obj) from start to end\u20131 in the invoking list. Elements in the returned list are also referenced by the List subList(int start, int end) invoking object. 10 [PAGE 11] The Collection Classes Interface Description AbstractCollection Implements most of the Collection interface. AbstractList Extends AbstractCollection and implements most of the List interface. AbstractSequentialList Extends AbstractList for use by a collection that uses sequential rather than random access of its elements. LinkedList Implements a linked list by extending AbstractSequentialList ArrayList Implements a dynamic array by extending AbstractList AbstractSet Extends AbstractCollection and implements most",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_4",
    "text": "of the Set interface HashSet Extends AbstractSet for use with a hash table LinkedHashSet Extends HashSet to allow insertion-order iterations. TreeSet Implements a set stored in a tree. Extends AbstractSet. 11 [PAGE 12] List interface List interface is the child interface of Collection interface. It inhibits a list type data \u25aa structure in which we can store the ordered collection of objects. It can have duplicate values. List interface is implemented by the classes ArrayList, LinkedList, Vector, and Stack. \u25aa To instantiate the List interface, we must use : \u25aa List <data-type> list1= new ArrayList(); List <data-type> list2 = new LinkedList(); List <data-type> list3 = new Vector(); List <data-type> list4 = new Stack(); There are various methods in List interface that can be used to insert, delete, and access \u25aa the elements from the list. 12 [PAGE 13] The ArrayList Class The ArrayList class extends AbstractList and implements the List interface. \u25aa ArrayList supports dynamic arrays that can grow as needed. In Java, standard arrays are of \u25aa a fixed length. After arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold. sometimes, you may not know",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_5",
    "text": "until run time precisely how large of an array you need. \u25aa To handle this situation, the collections framework defines ArrayList. \u25aa In essence, an ArrayList is a variable-length array of object references. That is, an ArrayList \u25aa can dynamically increase or decrease in size. Array lists are created with an initial size. \u25aa When this size is exceeded, the collection is automatically enlarged. \u25aa 13 [PAGE 14] The ArrayList Class ArrayList has the constructors \u25aa ArrayList( ) : empty array list. ArrayList(Collection c) : array list that is initialized with the elements of the collection c ArrayList(int capacity) : array list that has the specified initial capacity. The capacity is the size of the underlying array that is used to store the elements. The capacity grows automatically as elements are added to an array list. 14 [PAGE 15] // Demonstrate ArrayList. // display the array list import java.util.*; System.out.println(\"Contents of al: \" + al); // Remove elements from the array list class ArrayListDemo { al.remove(\"F\"); public static void main(String args[]) { al.remove(2); // create an array list System.out.println(\"Size of al after deletions: \" + al.size()); ArrayList al = new ArrayList(); System.out.println(\"Contents of al: \" + al); System.out.println(\"Initial size of",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_6",
    "text": "al: \" + al.size()); } // add elements to the array list } al.add(\"C\"); al.add(\"A\"); al.add(\"E\"); Output: al.add(\"B\"); Initial size of al: 0 al.add(\"D\"); Size of al after additions: 7 al.add(\"F\"); Contents of al: [C, A2, A, E, B, D, F] al.add(1, \"A2\"); Size of al after deletions: 5 System.out.println(\"Size of al after additions: \" + Contents of al: [C, A2, E, B, D] al.size()); 15 [PAGE 16] Obtaining an Array from an ArrayList When working with ArrayList, you will sometimes want to obtain an actual \u25aa array that contains the contents of the list. you can do this by calling toArray( ). Several reasons exist why you might want to convert a collection into an \u25aa array such as: \u25a0 To obtain faster processing times for certain operations. \u25a0 To pass an array to a method that is not overloaded to accept a collection. \u25a0 To integrate your newer, collection-based code with legacy code that does not understand collections. 16 [PAGE 17] // Convert an ArrayList into an array. // sum the array for(int i=0; i<ia.length; i++) import java.util.*; sum += ((Integer) ia[i]).intValue(); class ArrayListToArray { System.out.println(\"Sum is: \" + sum); public static void main(String args[]) } { }",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_7",
    "text": "// Create an array list Output: ArrayList al = new ArrayList(); Contents of al: [1, 2, 3, 4] // Add elements to the array list Sum is: 10 al.add(new Integer(1)); al.add(new Integer(2)); you cannot store primitive types in a collection, so objects of al.add(new Integer(3)); type Integer are created and stored. al.add(new Integer(4)); Next, toArray( ) is called and it obtains an array of Objects. System.out.println(\"Contents of al: \" + al); The contents of this array are cast to Integer, and then the // get array values are summed. Object ia[] = al.toArray(); int sum = 0; 17 [PAGE 18] Vector Vector uses a dynamic array to store the data elements. It is similar to ArrayList. \u25aa However, It is synchronized and contains many methods that are not the part of Collection framework. Consider the following example. import java.util.*; public class TestJavaCollection3{ public static void main(String args[]){ Output: Vector<String> v=new Vector<String>(); Ayush v.add(\"Ayush\"); Amit v.add(\"Amit\"); Ashish v.add(\"Ashish\"); Garima v.add(\"Garima\"); Iterator<String> itr=v.iterator(); while(itr.hasNext()){ System.out.println(itr.next()); } } } 18 [PAGE 19] stack The stack is the subclass of Vector. It implements the last-in-first-out data structure, i.e., Stack. \u25aa The stack contains all of the methods of Vector class and also provides its",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-4.2 Collections Framework_8",
    "text": "methods like boolean push(), boolean peek(), boolean push(object o), which defines its properties. Consider the following example. import java.util.*; public class TestJavaCollection4{ public static void main(String args[]){ Output: Stack<String> stack = new Stack<String>(); stack.push(\"Ayush\"); Ayush stack.push(\"Garvit\"); Amit stack.push(\"Amit\"); Ashish stack.push(\"Ashish\"); Garima stack.push(\"Garima\"); stack.pop(); Iterator<String> itr=stack.iterator(); while(itr.hasNext()){ System. out.println(itr.next()); https://www.javatpoint.com/collections-in-java } } } 19",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.2 Collections Framework.txt"
    }
  },
  {
    "id": "Unit-2.2 Keywords_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-2.2 Keywords.pdf] [PAGE 1] Content 1. this Keyword 2. final Keyword 3. Recursion 4. Operator \u2018instanceof\u2019 5. enum class [PAGE 2] 1. this Keyword [PAGE 3] this keyword In Java, this is a reference variable that refers to the current object. Usages of Java this keywor 1. this can be used to refer current class instance variable. 2. this can be used to invoke current class method (implicitly) 3. this() can be used to invoke current class constructor. 4. this can be passed as an argument in the method call. 5. this can be passed as argument in the constructor call. 6. this can be used to return the current class instance from the method. [PAGE 4] Refer Current Class Instance Variable Resolve the problem of Ambiguity between the instance variables and parameters (local variables). class Student{ int rollno; String name; float fee; Student(int rollno, String name, float fee) { rollno=rollno; name=name; fee=fee; } void display() { System.out.println(rollno+\" \"+name+\" \"+fee);} } [PAGE 5] Refer Current Class Instance Variable class TestStudent{ public static void main(String args[]){ Student s1=new Student(111,\"ankit\",5000f); Student s2=new Student(112,\"sumit\",6000f); s1.display(); s2.display(); }} The execution result due to ambiquity is: 0 null 0.0 0",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.2 Keywords.txt"
    }
  },
  {
    "id": "Unit-2.2 Keywords_1",
    "text": "null 0.0 To resolve the ambiquity, use this keyword in this.rollno = rollno; this.name = name; this.fee = fee; [PAGE 6] Invoke the Current Class Method Suppose if the programmer not provide the this keyword to access the current class method, Java compiler add \u201cthis\u201d keyword automatically. class ArithmeticOperations { void addition() { } void subtraction () { } addition(); // compiler convert this.addition(); } public static void main(String[] a) { new ArithmeticOperations().subtraction(); [PAGE 7] Invoke the Current Class Constructor Current class constructor to be invoked and reused by this keyword. Calling default constructor from parameterized constructor class Calculate { Calculate c= new Calculate(5,5); Calculate() { System.out.println(\u201cHello World\u201d); } Calculate(int x, int y) { this(); System.out.println(x*y); }} [PAGE 8] Invoke the Current Class Constructor Calling parameterized constructor from default constructor class Calculate { Calculate() { Calculate c= new Calculate(); this(5,5); System.out.println(\u201cHello World\u201d); } Calculate(int x, int y) { System.out.println(x*y); }} Constructor Chain? [PAGE 9] 2. final Keyword [PAGE 10] JAVA final Keyword The final keyword in java is used to restrict the user. The java final keyword can be used in many context. Final can be: variable method class The final keyword can be applied with the variables, a final",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.2 Keywords.txt"
    }
  },
  {
    "id": "Unit-2.2 Keywords_2",
    "text": "variable that have no value it is called blank final variable or uninitialized final variable. It can be initialized in the constructor only. The blank final variable can be static also which will be initialized in the static block only. We will have detailed learning of these. Let's first learn the basics of final keyword. 1) Java final variable If you make any variable as final, you cannot change the value of final variable(It will be constant). Example of final variable There is a final variable speedlimit, we are going to change the value of this variable, but It can't be changed because final variable once assigned a value can never be changed. [PAGE 11] JAVA final Keyword contd... Final Variable: class Bike9{ final int speedlimit=90;//final variable void run(){ speedlimit=400; } public static void main(String args[]){ Bike9 obj=new Bike9(); obj.run(); } }//end of class Output: Compile Time Error [PAGE 12] JAVA final Keyword contd... Final Method: If you make any method as final, you cannot override it. class Bike{ final void run(){System.out.println(\"running\");} } class Honda extends Bike{ void run(){System.out.println(\"Running safely with 100kmph\");} public static void main(String args[]){ Honda honda= new Honda(); honda.run(); } Output: Compile Time Error } [PAGE 13]",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.2 Keywords.txt"
    }
  },
  {
    "id": "Unit-2.2 Keywords_3",
    "text": "JAVA final Keyword contd... Final Class: If you make any class as final, you cannot extend it. final class Bike { } class Honda extends Bike{ void run(){System.out.println(\"Running safely with 100kmph\");} public static void main(String args[]){ Honda honda= new Honda(); honda.run(); } Output: Compile Time Error } [PAGE 14] Where to apply final Keyword? Q) What is blank or uninitialized final variable? A final variable that is not initialized at the time of declaration is known as blank final variable. If you want to create a variable that is initialized at the time of creating object and once initialized may not be changed, it is useful. For example PAN CARD number of an employee. It can be initialized only in constructor. Example of blank final variable class Student { int id; String name; final String PAN_CARD_NUMBER; ... } [PAGE 15] Where to apply final Keyword? Que) Can we initialize blank final variable? Yes, but only in constructor. class Bike10{ final int speedlimit; //blank final variable Bike10(){ speedlimit=70; System.out.println(speedlimit); } public static void main(String args[]){ new Bike10(); } } [PAGE 16] Where to apply final Keyword? static blank final variable A static final variable that is not initialized at the time",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.2 Keywords.txt"
    }
  },
  {
    "id": "Unit-2.2 Keywords_4",
    "text": "of declaration is known as static blank final variable. It can be initialized only in static block. Example of static blank final variable class A { static final int data; //static blank final variable static { data=50;} public static void main(String args[]) { System.out.println(A.data); } } [PAGE 17] 3. Recursion [PAGE 18] Recursion in JAVA Recursion in java is a process in which a method calls itself continuously. A method in java that calls itself is called recursive method. It makes the code compact but complex to understand. Syntax: returntype methodname(){ method body; //code to be executed methodname(); //calling same method } [PAGE 19] Recursion in JAVA \u2013 Infinite Times public class RecursionInfinite { static void test() { System.out.println(\"Hello World\"); test(); } public static void main(String[] args) { test(); } } [PAGE 20] Recursion in JAVA \u2013 Finite Times public class RecursionFinite { static int count=0; static void test() { count++; if(count<=5) { System.out.println(\"Hello World\" +count); test(); } public static void main(String[] args) { test(); } } [PAGE 21] Recursion in JAVA \u2013 Practices 1. Factorial 2. Fibonacci Series [PAGE 22] 4. Operator \u2018instanceof\u2019 [PAGE 23] JAVA \u2018instanceof\u2019 Operator The java instanceof operator is used to test whether the object",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.2 Keywords.txt"
    }
  },
  {
    "id": "Unit-2.2 Keywords_5",
    "text": "is an instance of the specified type (class or subclass or interface). The \u2018instanceof\u2019 in java is also known as type comparison operator because it compares the instance with type. It returns either true or false. If we apply the instanceof operator with any variable that has null value, it returns false. Simple example of java instanceof Let's see the simple example of instance operator where it tests the current class. class Simple1{ public static void main(String args[]) { Simple1 s=new Simple1(); System.out.println(s instanceof Simple1); //true } } [PAGE 24] JAVA \u2018instanceof\u2019 Operator An object of subclass type is also a type of parent class. For example, if Dog extends Animal then object of Dog can be referred by either Dog or Animal class. Another example of java instanceof operator class Animal{} class Dog1 extends Animal{//Dog inherits Animal public static void main(String args[]){ Dog1 d=new Dog1(); System.out.println(d instanceof Animal);//true } } [PAGE 25] JAVA \u2018instanceof\u2019 Operator instanceof in java with a variable that have null value If we apply instanceof operator with a variable that have null value, it returns false. class Dog2{ public static void main(String args[]){ Dog2 d=null; System.out.println(d instanceof Dog2); //false } } [PAGE 26] 5. enum",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.2 Keywords.txt"
    }
  },
  {
    "id": "Unit-2.2 Keywords_6",
    "text": "class [PAGE 27] JAVA enum class The enum in Java is a data type which contains a fixed set of constants. It can be used for days of the week (SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, and SATURDAY) , directions (NORTH, SOUTH, EAST, and WEST), season (SPRING, SUMMER, WINTER, and AUTUMN or FALL), colors (RED, YELLOW, BLUE, GREEN, WHITE, and BLACK) etc. According to the Java naming conventions, we should have all constants in capital letters. So, we have enum constants in capital letters. Java enums can be thought of as classes which have a fixed set of constants (a variable that does not change). The Java enum constants are static and final implicitly. It is available since JDK 1.5. Enums are used to create our own data type like classes. The enum data type (also known as Enumerated Data Type) is used to define an enum in Java. Unlike C/C++, enum in Java is more powerful. Here, we can define an enum either inside the class or outside the class. [PAGE 28] JAVA enum class Java Enum internally inherits the Enum class, so it cannot inherit any other class, but it can implement many interfaces. We can have fields,",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.2 Keywords.txt"
    }
  },
  {
    "id": "Unit-2.2 Keywords_7",
    "text": "constructors, methods, and main methods in Java enum. Points to remember for Java Enum Enum improves type safety Enum can be easily used in switch Enum can be traversed Enum can have fields, constructors and methods Enum may implement many interfaces but cannot extend any class because it internally extends Enum class [PAGE 29] JAVA enum class Simple Example of Java Enum class EnumExample1{ //defining the enum inside the class public enum Season { WINTER, SPRING, SUMMER, FALL } //main method public static void main(String[] args) { //traversing the enum for (Season s : Season.values()) System.out.println(s); }} [PAGE 30] JAVA enum class Java Enum Example: Defined inside class class EnumExample2{ enum Season { WINTER, SPRING, SUMMER, FALL; } //semicolon(;) is optional here public static void main(String[] args) { Season s=Season.WINTER; //enum type is required to access WINTER System.out.println(s); }}",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.2 Keywords.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-4.1 Srings - Array.pdf] [PAGE 1] CSE 2006 - Programming in Java Course Type: LP Credits: 3 Prepared by C.S Rajpoot School of Computing Science and Engineering VIT Bhopal University [PAGE 2] Unit- 4 Java List & I/O Streams String classes, methods, operations on Strings and 1-D Arrays, 2-D and Jagged Arrays and its operations Java Collections Framework, Java Collection Interface, Java List Interface, Java Array List, Java Vector, Java Stack Streams: Introduction to Byte-oriented and Character-oriented streams, Java I/O Streams, and Java Reader/Writer 2 [PAGE 3] Java string classes In Java, string is basically an object that represents sequence of char values. An array of characters works same as Java string. For example: char[] ch={'j','a','v','a','t','p','o','i','n','t'}; String s=new String(ch); is same as: String s=\"javaprogramming\"; Java String class provides a lot of methods to perform operations on strings such as compare(), concat(), equals(), split(), length(), replace(), compareTo(), intern(), substring() etc. The java.lang.String class implements Serializable, Comparable and CharSequence interfaces. 3 [PAGE 4] Java string classes What is String in Java? Generally, String is a sequence of characters. But in Java, string is an object that represents a sequence of characters. The java.lang.String class is used to",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_1",
    "text": "create a string object. How to create a string object? There are two ways to create String object: 1. By string literal 2. By new keyword 4 [PAGE 5] Java string classes 1) String Literal Java String literal is created by using double quotes. For Example: String s=\"welcome\"; Each time you create a string literal, the JVM checks the \"string constant pool\" first. If the string already exists in the pool, a reference to the pooled instance is returned. If the string doesn't exist in the pool, a new string instance is created and placed in the pool. For example: String s1=\"Welcome\"; String s2=\"Welcome\";//It doesn't create a new instance Why Java uses the concept of String literal? To make Java more memory efficient (because no new objects are created if it exists already in the string constant pool). 5 [PAGE 6] Java string classes 2) By new keyword String s=new String(\"Welcome\"); //creates two objects and one reference variable In such case, JVM will create a new string object in normal (non-pool) heap memory, and the literal \"Welcome\" will be placed in the string constant pool. The variable s will refer to the object in a heap (non-pool). 6 [PAGE 7]",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_2",
    "text": "Java string classes Java String Example StringExample.java public class StringExample{ public static void main(String args[]){ String s1=\"java\";//creating string by Java string literal char ch[]={'s','t','r','i','n','g','s'}; String s2=new String(ch);//converting char array to string String s3=new String(\"example\");//creating Java string by new keyword System.out.println(s1); Output: System.out.println(s2); java System.out.println(s3); strings example }} The above code, converts a char array into a String object. And displays the String objects s1, s2, and s3 on console using println() method. 7 [PAGE 8] Java String class method No. Method Description 1 char charAt(int index) It returns char value for the particular index 2 int length() It returns string length 3 static String format(String format, It returns a formatted string. Object... args) 4 static String format(Locale l, String format, It returns formatted string with given Object... args) locale. 5 String substring(int beginIndex) It returns substring for given begin index. 6 String substring(int beginIndex, int It returns substring for given begin index endIndex) and end index. 7 boolean contains(CharSequence s) It returns true or false after matching the sequence of char value. 8 static String join(CharSequence delimiter, It returns a joined string. CharSequence... elements) 9 static String join(CharSequence delimiter, It returns a joined string. Iterable<? extends CharSequence> elements) 10 boolean",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_3",
    "text": "equals(Object another) It checks the equality of string with the given object. 8 [PAGE 9] Java String class method No. Method Description 11 boolean isEmpty() It checks if string is empty. 12 String concat(String str) It concatenates the specified string. 13 String replace(char old, char new) It replaces all occurrences of the specified char value. 14 String replace(CharSequence old, It replaces all occurrences of the CharSequence new) specified CharSequence. 15 static String equalsIgnoreCase(String It compares another string. It doesn't another) check case. 16 String[] split(String regex) It returns a split string matching regex. 17 String[] split(String regex, int limit) It returns a split string matching regex and limit. 18 String intern() It returns an interned string. 19 int indexOf(int ch) It returns the specified char value index. 20 int indexOf(int ch, int fromIndex) It returns the specified char value index starting with given index. 21 int indexOf(String substring) It returns the specified substring index. 9 [PAGE 10] Java String class method No. Method Description 22 int indexOf(String substring, int It returns the specified substring index fromIndex) starting with given index. 23 String toLowerCase() It returns a string in lowercase. 24 String toLowerCase(Locale l) It returns a string in lowercase using",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_4",
    "text": "specified locale. 25 String toUpperCase() It returns a string in uppercase. 26 String toUpperCase(Locale l) It returns a string in uppercase using specified locale. 27 String trim() It removes beginning and ending spaces of this string. 28 static String valueOf(int value) It converts given type into string. It is an overloaded method. 10 [PAGE 11] String Length length of a string is the number of characters that it contains String s = \u201cSample\u201d; System.out.println(s.length()); //6 Special String Operations String Literals \u25aa Explicitly create a String instance from an array of characters by using the new \u25aa operator. char chars[] = { 'a', 'b', 'c' }; String s1 = new String(chars); String s2 = \"abc\"; System.out.println(\"abc\".length()); String Concatenation \u25aa + operator. \u25aa String age = \"9\u201c; String s = \"He is \" + age + \" years old.\u201c; System.out.println(s); He is 9 years old. 11 [PAGE 12] Special String Operations String Concatenation with Other Data Types String s = \"four: \" + 2 + 2; System.out.println(s); four: 22 String s = \"four: \" + (2 + 2); four: 4 String Conversion and toString( ) valueOf( ) is overloaded for all the simple types and for type Object. For the simple types,",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_5",
    "text": "valueOf( ) returns a string that contains the human-readable equivalent of the value with which it is called. For objects, valueOf( ) calls the toString( ) method on the object. Every class implements toString( ) because it is defined by Object String toString( ) To implement toString( ), simply return a String object that contains the human-readable string that appropriately describes an object of your class. 12 [PAGE 13] class Box { double width; double height; double depth; Box(double w, double h, double d) { width = w; height = h; Output: depth = d; Dimensions are 10.0 by 14.0 by 12.0 } Box b: Dimensions are 10.0 by 14.0 by 12.0 public String toString() { return \"Dimensions are \" + width + \" by \" + depth + \" by \" + height + \".\"; } } class toStringDemo { public static void main(String args[]) { Box b = new Box(10, 12, 14); String s = \"Box b: \" + b; // concatenate Box object System.out.println(b); // convert Box to string System.out.println(s); } } 13 [PAGE 14] Character Extraction charAt( ) To extract a single character from a String char charAt(int where) char ch; ch = \"abc\".charAt(1); Output :",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_6",
    "text": "a getChars( ) If you need to extract more than one character at a time void getChars(int sourceStart, int sourceEnd, char target[ ], int targetStart) String s = \"This is a demo of the getChars method.\"; s.getChars(start, end, buf, 0); System.out.println(buf); Output : demo getBytes( ) that stores the characters in an array of bytes - byte[ ] getBytes( ) toCharArray( ) convert all the characters in a String object into a character array - char[ ] toCharArray( ) 14 [PAGE 15] String Comparison equals( ) and equalsIgnoreCase( ) Compare two strings for equality - boolean equals(Object str) Comparison that ignores case differences - boolean equalsIgnoreCase(String str) regionMatches( ) Compares a specific region inside a string with another specific region in another string boolean regionMatches(int startIndex, String str2, int str2StartIndex, int numChars) boolean regionMatches(boolean ignoreCase,int startIndex,String str2,int str2StartIndex,int numChars) startsWith( ) and endsWith( ) The startsWith( ) method determines whether a given String begins with a specified string The endsWith( ) determines whether the String in question ends with a specified string. \"Foobar\".endsWith(\"bar\") and \"Foobar\".startsWith(\"Foo\") -> true 15 [PAGE 16] String Comparison equals( ) Versus == The equals( ) method compares the characters inside a String object. The == operator",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_7",
    "text": "compares two object references to see whether they refer to the same instance. String s1 = \"Hello\u201c; String s2 = new String(s1); System.out.println(s1 + \" equals \" + s2 + \" -> \" + s1.equals(s2)); TRUE System.out.println(s1 + \" == \" + s2 + \" -> \" + (s1 == s2)); FALSE compareTo( ) String being compared with the invoking String compareToIgnoreCase( ) - want to ignore case differences when comparing two strings int compareToIgnoreCase(String str) Value Meaning Less than zero The invoking string is less than str in dictionary order. Greater than The invoking string is greater than str in dictionary zero order. Zero The two strings are equal. 16 [PAGE 17] Searching Strings To search a string for a specified character or substring indexOf( ) Searches for the first occurrence of a character or substring. lastIndexOf( ) Searches for the last occurrence of a character or substring. int indexOf(int ch) int lastIndexOf(int ch) int indexOf(String str) int lastIndexOf(String str) int indexOf(int ch, int startIndex) int lastIndexOf(int ch, int startIndex) int indexOf(String str, int startIndex) int lastIndexOf(String str, int startIndex) 17 [PAGE 18] // Demonstrate indexOf() and lastIndexOf(). class indexOfDemo { public static void main(String args[]) { String s",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_8",
    "text": "= \"Now is the time for all good men to come to the aid of their country.\"; System.out.println(s); System.out.println(\"indexOf(t) = \" +s.indexOf('t')); System.out.println(\"lastIndexOf(t) = \" +s.lastIndexOf('t')); System.out.println(\"indexOf(the) = \" +s.indexOf(\"the\")); System.out.println(\"lastIndexOf(the) = \" +s.lastIndexOf(\"the\")); System.out.println(\"indexOf(t, 10) = \" +s.indexOf('t', 10)); System.out.println(\"lastIndexOf(t, 60) = \" +s.lastIndexOf('t', 60)); System.out.println(\"indexOf(the, 10) = \" +s.indexOf(\"the\", 10)); System.out.println(\"lastIndexOf(the, 60) = \" +s.lastIndexOf(\"the\", 60)); } Output: } Now is the time for all good men to come to the aid of their country. indexOf(t) = 7 lastIndexOf(t) = 65 indexOf(the) = 7 lastIndexOf(the) = 55 indexOf(t, 10) = 11 lastIndexOf(t, 60) = 55 indexOf(the, 10) = 44 lastIndexOf(the, 60) = 55 18 [PAGE 19] Modifying a String substring( ) - To extract a substring String substring(int startIndex) String substring(int startIndex, int endIndex) concat( ) \u2013 To concatenate two strings String concat(String str) String s1 = \"one\"; String s2 = s1.concat(\"two\"); || String s2 = s1 + \"two\"; replace( ) - replaces all occurrences one character in invoking string with another character. String replace(char original, char replacement) String s = \"Hello\".replace('l', 'w'); Output: Hewwo trim( ) - returns a copy of the invoking string from which any leading and trailing whitespace has been removed. String trim( )",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_9",
    "text": "String s = \" Hello World \".trim(); Output: Hello World 19 [PAGE 20] // Substring replacement. result = result + org.substring(i + class StringReplace { search.length()); public static void main(String args[]) { org = result; String org = \"This is a test. } This is, too.\"; } while(i != -1); String search = \"is\"; } String sub = \"was\"; } String result = \"\"; Output : This is a test. This is, too. int i; Thwas is a test. This is, too. do { // replace all matching Thwas was a test. This is, too. substrings Thwas was a test. Thwas is, too. System.out.println(org); Thwas was a test. Thwas was, too. i = org.indexOf(search); if(i != -1) { result = org.substring(0, i); result = result + sub; 20 [PAGE 21] Changing the Case of Characters Within a String String toLowerCase( ) String toUpperCase( ) Example: String s = \"This is a test.\"; String upper = s.toUpperCase(); THIS IS A TEST. String lower = s.toLowerCase(); this is a test. 21 [PAGE 22] Mind Map 22 [PAGE 23] Array Array is a collection of similar type of elements which has contiguous memory location. Java array is an object which contains elements of",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_10",
    "text": "a similar data type. Additionally, The elements of an array are stored in a contiguous memory location. It is a data structure where we store similar elements. We can store only a fixed set of elements in a Java array. Array in Java is index-based, the first element of the array is stored at the 0th index, 2nd element is stored on 1st index and so on. Unlike C/C++, we can get the length of the array using the length member. In C/C++, we need to use the sizeof operator. 23 [PAGE 24] Array Serializable as well as Cloneable interfaces. We can store primitive values or objects in an array in Java. Like C/C++, we can also create single dimentional or multidimentional arrays in Java. Moreover, Java provides the feature of anonymous arrays which is not available in C/C++. 24 [PAGE 25] Array Advantages Code Optimization: It makes the code optimized, we can retrieve or sort the data efficiently. Random access: We can get any data located at an index position. Disadvantages Size Limit: We can store only the fixed size of elements in the array. It doesn't grow its size at runtime. To solve this problem, collection framework is",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_11",
    "text": "used in Java which grows automatically. 25 [PAGE 26] Array Types of Array in java There are two types of array. 1. Single Dimensional Array 2. Multidimensional Array Single Dimensional Array in Java Syntax to Declare an Array in Java dataType[] arr; (or) dataType []arr; (or) dataType arr[]; Instantiation of an Array in Java arrayRefVar=new datatype[size]; 26 [PAGE 27] Array Example of Java Array Let's see the simple example of java array, where we are going to declare, instantiate, initialize and traverse an array. //Java Program to illustrate how to declare, instantiate, initialize and travers e the Java array. class Testarray{ public static void main(String args[]){ Output: int a[]=new int[5];//declaration and instantiation 10 a[0]=10; //initialization 20 a[1]=20; 70 a[2]=70; 40 a[3]=40; 50 a[4]=50; //traversing array for(int i=0;i<a.length;i++) //length is the property of array System.out.println(a[i]); }} 27 [PAGE 28] Array Declaration, Instantiation and Initialization of Java Array We can declare, instantiate and initialize the java array together by: int a[]={33,3,4,5};//declaration, instantiation and initialization Let's see the simple example to print this array. //Java Program to illustrate the use of declaration, instantiation and initializatio n of Java array in a single line class Testarray1{ Output: public static void main(String args[]){ 33 int",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_12",
    "text": "a[]={33,3,4,5};//declaration, instantiation and initialization 3 //printing array 4 for(int i=0;i<a.length;i++)//length is the property of array 5 System.out.println(a[i]); }} 28 [PAGE 29] Array Multidimensional Array in Java In such case, data is stored in row and column based index (also known as matrix form). Syntax to Declare Multidimensional Array in Java dataType[][] arrayRefVar; (or) dataType [][]arrayRefVar; (or) dataType arrayRefVar[][]; (or) dataType []arrayRefVar[]; Example to instantiate Multidimensional Array in Java int[][] arr=new int[3][3]; //3 row and 3 column 29 [PAGE 30] Array Example to initialize Multidimensional Array in Java arr[0][0]=1; arr[0][1]=2; arr[0][2]=3; arr[1][0]=4; arr[1][1]=5; arr[1][2]=6; arr[2][0]=7; arr[2][1]=8; arr[2][2]=9; 30 [PAGE 31] Array Example of Multidimensional Java Array Let's see the simple example to declare, instantiate, initialize and print the 2Dimensional array. //Java Program to illustrate the use of multidimensional array class Testarray3{ public static void main(String args[]){ //declaring and initializing 2D array int arr[][]={{1,2,3},{2,4,5},{4,4,5}}; //printing 2D array for(int i=0;i<3;i++){ Output: for(int j=0;j<3;j++){ 1 2 3 System.out.print(arr[i][j]+\" \"); 2 4 5 } System.out.println(); 4 4 5 } }} 31 [PAGE 32] Array 0 1 2 3 4 5 6 7 8 Jagged Array in Java If we are creating odd number of columns in a 2D array, it is known as a jagged",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_13",
    "text": "array. In other words, it is an array of arrays with different number of columns. //Java Program to illustrate the jagged array Output: class TestJaggedArray{ 0 1 2 public static void main(String[] args){ 3 4 5 6 //declaring a 2D array with odd columns 7 8 int arr[][] = new int[3][]; arr[0] = new int[3]; //printing the data of a jagged array arr[1] = new int[4]; for (int i=0; i<arr.length; i++){ for (int j=0; j<arr[i].length; j++){ arr[2] = new int[2]; System.out.print(arr[i][j]+\" \"); //initializing a jagged array } int count = 0; System.out.println();//new line for (int i=0; i<arr.length; i++) } for(int j=0; j<arr[i].length; j++) } arr[i][j] = count++; } 32 [PAGE 33] Array 0 1 2 3 4 5 6 7 8 Addition of 2 Matrices in Java //Java Program to demonstrate the addition of two matrices in Java class Testarray5{ public static void main(String args[]){ //creating two matrices int a[][]={{1,3,4},{3,4,5}}; int b[][]={{1,3,4},{3,4,5}}; //creating another matrix to store the sum of two matrices int c[][]=new int[2][3]; //adding and printing addition of 2 matrices for(int i=0;i<2;i++){ Output: for(int j=0;j<3;j++){ 2 6 8 c[i][j]=a[i][j]+b[i][j]; 6 8 10 System.out.print(c[i][j]+\" \"); } System.out.println();//new line } }} 33 [PAGE 34] Array 0 1 2 3 4",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "Unit-4.1 Srings - Array_14",
    "text": "5 6 7 8 Multiplication of 2 Matrices in Java In the case of matrix multiplication, a one-row element of the first matrix is multiplied by all the columns of the second matrix which can be understood by the image given below. 34 [PAGE 35] Array 0 1 2 3 4 5 6 7 8 //Java Program to multiply two matrices public class MatrixMultiplicationExample{ public static void main(String args[]){ //creating two matrices int a[][]={{1,1,1},{2,2,2},{3,3,3}}; int b[][]={{1,1,1},{2,2,2},{3,3,3}}; //creating another matrix to store the multiplication of two matrices int c[][]=new int[3][3]; //3 rows and 3 columns //multiplying and printing multiplication of 2 matrices for(int i=0;i<3;i++){ for(int j=0;j<3;j++){ Output: c[i][j]=0; 6 6 6 for(int k=0;k<3;k++) 12 12 12 { c[i][j]+=a[i][k]*b[k][j]; 18 18 18 }//end of k loop System.out.print(c[i][j]+\" \"); //printing matrix element }//end of j loop System.out.println();//new line } }} 35",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-4.1 Srings - Array.txt"
    }
  },
  {
    "id": "1.2_0",
    "text": "TOPIC: [UNIT: Unit1_Basics] Definition: [SOURCE_FILE: 1.2.pptx] 1. JAVA Variables JAVA Variables A variable is a container which holds the value while the Java program is executed. A variable is assigned with a data type. Variable is a name of memory location. There are three types of variables in java: local, instance and static. There are two types of data types in Java: primitive and non-primitive. A variable is the name of a reserved area allocated in memory. In other words, it is a name of the memory location. It is a combination of \"vary + able\" which means its value can be changed. int a = 10; JAVA Variables contd... There are three types of variables in Java: 1) Local Variable A variable declared inside the body of the method is called local variable. You can use this variable only within that method and the other methods in the class aren't even aware that the variable exists. A local variable cannot be defined with \"static\" keyword. 2) Instance Variable A variable declared inside the class but outside the body of the method, is called an instance variable. It is not declared as static. It is called an instance variable because",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "1.2_1",
    "text": "its value is instance-specific and is not shared among instances. 3) Static variable A variable that is declared as static is called a static variable. It cannot be local. You can create a single copy of the static variable and share it among all the instances of the class. Memory allocation for static variables happens only once when the class is loaded in the memory. JAVA Variables contd... Example public class A { static int m=100; //static variable void method() { int n=90; //local variable } public static void main(String args[]) { int data=50; //instance variable } }//end of class 2. JAVA Data Types JAVA Data Types Data types specify the different sizes and values that can be stored in the variable. There are two types of data types in Java: Primitive data types: The primitive data types include boolean, char, byte, short, int, long, float and double. Non-primitive data types: The non-primitive data types include Classes, Interfaces, and Arrays. Java Primitive Data Types In Java language, primitive data types are the building blocks of data manipulation. These are the most basic data types available in Java language. Java is a statically-typed programming language. It means, all variables must be",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "1.2_2",
    "text": "declared before its use. That is why we need to declare variable's type and name. JAVA Data Types contd... JAVA Data Types contd... JAVA Data Types contd... Boolean Data Type The Boolean data type is used to store only two possible values: true and false. This data type is used for simple flags that track true/false conditions. The Boolean data type specifies one bit of information, but its \"size\" can't be defined precisely. Example: Boolean one = false Byte Data Type The byte data type is an example of primitive data type. It is an 8-bit signed two's complement integer. Its value-range lies between -128 to 127 (inclusive). Its minimum value is -128 and maximum value is 127. Its default value is 0. The byte data type is used to save memory in large arrays where the memory savings is most required. It saves space because a byte is 4 times smaller than an integer. It can also be used in place of \"int\" data type. Example: byte a = 10, byte b = -20 JAVA Data Types contd... Short Data Type The short data type is a 16-bit signed two's complement integer. Its value-range lies between -32,768 to 32,767",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "1.2_3",
    "text": "(inclusive). Its minimum value is -32,768 and maximum value is 32,767. Its default value is 0. The short data type can also be used to save memory just like byte data type. A short data type is 2 times smaller than an integer. short s = 10000, short r = -5000 Int Data Type The int data type is a 32-bit signed two's complement integer. Its value-range lies between - 2,147,483,648 (-2^31) to 2,147,483,647 (2^31 -1) (inclusive). Its minimum value is - 2,147,483,648and maximum value is 2,147,483,647. Its default value is 0. The int data type is generally used as a default data type for integral values unless if there is no problem about memory. int a = 100000, int b = -200000 JAVA Data Types contd... Long Data Type The long data type is a 64-bit two's complement integer. Its value-range lies between -9,223,372,036,854,775,808(-2^63) to 9,223,372,036,854,775,807(2^63 1)(inclusive). Its minimum value is - 9,223,372,036,854,775,808and maximum value is 9,223,372,036,854,775,807. Its default value is 0. The long data type is used when you need a range of values more than those provided by int. Example: long a = 100000L, long b = -200000L Float Data Type The float data type is a",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "1.2_4",
    "text": "single-precision 32-bit IEEE 754 floating point.Its value range is unlimited. It is recommended to use a float (instead of double) if you need to save memory in large arrays of floating point numbers. The float data type should never be used for precise values, such as currency. Its default value is 0.0F. Example: float f1 = 234.5f JAVA Data Types contd... Double Data Type The double data type is a double-precision 64-bit IEEE 754 floating point. Its value range is unlimited. The double data type is generally used for decimal values just like float. The double data type also should never be used for precise values, such as currency. Its default value is 0.0d. Example: double d1 = 12.3 Char Data Type The char data type is a single 16-bit Unicode character. Its value-range lies between '\\u0000' (or 0) to '\\uffff' (or 65,535 inclusive).The char data type is used to store characters. Example: char letter = 'A' 3. JAVA Operators JAVA Operators Operators are symbols that perform operations on variables and values. For example, + is an operator used for addition, while * is also an operator used for multiplication. Java has 6 types 1. Arithmetic Operators 2. Assignment Operators",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "1.2_5",
    "text": "3. Relational Operators 4. Logical Operators 5. Unary Operators 6. Bitwise Operators JAVA Operators contd... Java Arithmetic Operators Arithmetic operators are used to perform arithmetic operations on variables and data. JAVA Operators contd... Java Logical Operators Logical operators are used to determine the logic between variables or values: 4. Java Expression Java Expression What is statement in Java? In Java, a statement is an executable instruction that tells the compiler what to perform. It forms a complete command to be executed and can include one or more expressions. A sentence forms a complete idea that can include one or more clauses. Expression Statements Expression is an essential building block of any Java program Generally, it is used to generate a new value. Sometimes, we can also assign a value to a variable In Java, expression is the combination of values, variables, operators, and method calls. Java Expression contd... There are three types of expressions in Java. 1. Expressions that produce a value. For example, (6+9), (9%2), (pi*radius) + 2. Note that the expression enclosed in the parentheses will be evaluate first, after that rest of the expression. 2. Expressions that assign a value. For example, number = 90, pi =",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "1.2_6",
    "text": "3.14. 3. Expression that neither produces any result nor assigns a value. For example, increment or decrement a value by using increment or decrement operator respectively, method invocation, etc. These expressions modify the value of a variable or state (memory) of a program. For example, count++, int sum = a + b; The expression changes only the value of the variable sum. The value of variables a and b do not change, so it is also a side effect. 5. Exercise on Sample Programs Exercise-1 //Java Unary Operator Example: ++ and -- public class OperatorExample{ public static void main(String args[]){ int x=10; System.out.println(x++); //10 (11) System.out.println(++x); //12 System.out.println(x--); //12 (11) System.out.println(--x); //10 }} Exercise-2 //Java Unary Operator Example 2: ++ and -- public class OperatorExample{ public static void main(String args[]){ int a=10; int b=10; System.out.println(a++ + ++a); //10+12=22 System.out.println(b++ + b++); //10+11=21 }} Exercise-3 //Java Unary Operator Example: ~ and ! public class OperatorExample{ public static void main(String args[]){ int a=10; int b=-10; boolean c=true; boolean d=false; System.out.println(~a); //-11 (minus of total positive value which starts from 0) System.out.println(~b); //9 (positive of total minus, positive starts from 0) System.out.println(!c); //false (opposite of boolean value) System.out.println(!d); //true }} Exercise-4 //Java Arithmetic",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "1.2_7",
    "text": "Operation using Expression public class OperatorExample{ public static void main(String args[]){ System.out.println(10*10/5+3-1*4/2); } } Exercise-5 Java Left Shift Operator The Java left shift operator << is used to shift all of the bits in a value to the left side of a specified number of times. //Java Left Shift Operation public class OperatorExample{ public static void main(String args[]){ System.out.println(10<<2); //10*2^2=10*4=40 System.out.println(10<<3); //10*2^3=10*8=80 System.out.println(20<<2); //20*2^2=20*4=80 System.out.println(15<<4); //15*2^4=15*16=240 }} Exercise-6 Java Right Shift Operator The Java right shift operator >> is used to move the value of the left operand to right by the number of bits specified by the right operand. //Java Right Shift Operation public OperatorExample{ public static void main(String args[]){ //10/2^2=10/4=2 //20/2^2=20/4=5 //20/2^3=20/8=2 System.out.println(10>>2); System.out.println(20>>2); System.out.println(20>>3); }} Exercise-7 Java Assignment Operator Java assignment operator is one of the most common operators. It is used to assign the value on its right to the operand on its left. //Java Assignment Operation-1 public class OperatorExample{ public static void main(String args[]){ int a=10; int b=20; a+=4; //a=a+4 (a=10+4) b-=4; //b=b-4 (b=20-4) System.out.println(a); System.out.println(b); }} Exercise-8 //Java Assignment Operation-2 public class OperatorExample{ public static void main(String[] args){ int a=10; a+=3; //10+3 System.out.println(a); a-=4; //13-4 System.out.println(a); a*=2; //9*2 System.out.println(a); a/=2; //18/2 System.out.println(a); }} Exercise-8",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "1.2_8",
    "text": "//Java Assignment Operation-3 public class OperatorExample{ public static void main(String args[]){ short a=10; short b=10; //a+=b; //a=a+b internally so fine a=a+b; //Compile time error because 10+10=20 now int System.out.println(a); }} Exercise-9 //Java type casting public class OperatorExample{ public static void main(String args[]){ short a=10; short b=10; a=(short)(a+b); //20 which is int now converted to short System.out.println(a); }} Exercise-10 // Java Arithmetic operations import java.io.*; class Arithmatic_Operations { public static void main(String args[]) {try{ DataInputStream din=new DataInputStream(System.in); System.out.println(\"Enter the 2-no's\"); System.out.println(\"multiplication is\" + (i*j)); System.out.println(\"divisionion is\" + (i/j)); System.out.println(\"modulo division is\" +(i%j)); }catch(Exception e) {} } }",
    "metadata": {
      "unit": "Unknown",
      "topic": "[UNIT: Unit1_Basics]",
      "source_file": "1.2.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_0",
    "text": "TOPIC: [SOURCE_TYPE: PDF] Definition: [FILE: Unit-2.1 Class.pdf] [PAGE 1] Content 1. JAVA Class and Objects 2. JAVA Methods 3. JAVA Constructors 4. JAVA Expression 5. Exercises [PAGE 2] Introduction Java OOP (Basics) Java Class and Objects, Java Methods, Java Constructor, Java Strings, Java Access Modifiers, Java this keyword, Java final keyword, Java Recursion, Java instance of Operator, Java Single Class and Anonymous Class, Java enum Class Java OOP (Inheritance & Polymorphism) Java Inheritance, Java Method Overriding, Java super Keyword, Abstract Class & Method, Java Interfaces, Java Polymorphism (overloading & overriding), Java Encapsulation Java OOP (Other types of classes) Nested & Inner Class, Java Static Class, Java Anonymous Class, Java Singleton, Java enum Class, Java enum Constructor, Java enum String, Java Reflection [PAGE 3] What do you understand? [PAGE 4] Java Class and Objects An object in Java is the physical as well as a logical entity, whereas, a class in Java is a logical entity only. What is an object in Java? An entity that has state and behavior is known as an object e.g., chair, bike, marker, pen, table, car, etc. It can be physical or logical (tangible and intangible). The example of an intangible object is the banking",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_1",
    "text": "system. [PAGE 5] Java Class and Objects An object has three characteristics: State: represents the data (value) of an object. Behavior: represents the behavior (functionality) of an object such as deposit, withdraw, etc. Identity: An object identity is typically implemented via a unique ID. The value of the ID is not visible to the external user. However, it is used internally by the JVM to identify each object uniquely. [PAGE 6] Java Class and Objects [PAGE 7] Java Class and Objects For Example, Pen is an object. Its name is Reynolds; color is white, known as its state. It is used to write, so writing is its behavior. An object is an instance of a class. A class is a template or blueprint from which objects are created. So, an object is the instance(result) of a class. Object Definitions: An object is a real-world entity. An object is a runtime entity. The object is an entity which has state and behavior. The object is an instance of a class. [PAGE 8] Java Class and Objects What is a class in Java A class is a group of objects which have common properties. It is a template or blueprint from which",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_2",
    "text": "objects are created. It is a logical entity. It can't be physical. A class in Java can contain: Fields Methods Constructors Blocks Nested class and interface Syntax to declare a class: class <class_name> { field; method; } [PAGE 9] Java Class and Objects Instance variable in Java A variable which is created inside the class but outside the method is known as an instance variable. Instance variable doesn't get memory at compile time. It gets memory at runtime when an object or instance is created. That is why it is known as an instance variable. new keyword in Java The new keyword is used to allocate memory at runtime. All objects get memory in Heap memory area. Method in Java In Java, a method is like a function which is used to expose the behavior of an object. Advantage of Method Code Reusability and Code Optimization [PAGE 10] Java Class and Objects Object and Class Example: main within the class created a Student class which has two data members id and name. We are creating the object of the Student class by new keyword and printing the object's value. Here, we are creating a main() method inside the class. File:",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_3",
    "text": "Student.java class Student{ //defining fields Output: int id; //field or data member or instance variable 0 String name; null //creating main method inside the Student class public static void main(String args[]){ //Creating an object or instance Student s1=new Student();//creating an object of Student //Printing values of the object System.out.println(s1.id);//accessing member through reference variable System.out.println(s1.name); } } [PAGE 11] Java Class and Objects Object and Class Example: main outside the class In real time development, we create classes and use it from another class. It is a better approach than previous one. Let's see a simple example, where we are having main() method in another class. We can have multiple classes in different Java files or single Java file. If you define multiple classes in a single Java source file, it is a good idea to save the file name with the class name which has main() method. [PAGE 12] Java Class and Objects 3 Ways to initialize object There are 3 ways to initialize object in Java. 1. By reference variable 2. By method 3. By constructor [PAGE 13] Java Class and Objects 1) Object and Class Example: Initialization through reference Initializing an object means storing data into the object.",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_4",
    "text": "Let's see a simple example where we are going to initialize the object through a reference variable. File: TestStudent2.java class Student{ int id; String name; } class TestStudent2{ public static void main(String args[]){ Student s1=new Student(); s1.id=10021; s1.name=\"SakthiSharma\"; System.out.println(s1.id+\" \"+s1.name);//printing members with a white space } } [PAGE 14] Java Class and Objects We can also create multiple objects and store information in it through reference variable. //Printing data File: TestStudent3.java System.out.println(s1.id+\" \"+s1.name); class Student{ System.out.println(s2.id+\" \"+s2.name); int id; } String name; } } class TestStudent3{ public static void main(String args[]){ //Creating objects Student s1=new Student(); Output: Student s2=new Student(); 101 Sonoo //Initializing objects 102 Amit s1.id=101; s1.name=\"Sonoo\"; s2.id=102; s2.name=\"Amit\"; [PAGE 15] Java Class and Objects 2) Object and Class Example: Initialization through method In this example, we are creating the two objects of Student class and initializing the value to these objects by invoking the insertRecord method. Here, we are displaying the state (data) of the objects by invoking the displayInformation() method. [PAGE 16] Java Class and Objects File: TestStudent4.java class Student{ int rollno; String name; void insertRecord(int r, String n){ rollno=r; name=n; } void displayInformation() {System.out.println(rollno+\" \"+name);} } class TestStudent4{ public static void main(String args[]){ Student s1=new Student();",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_5",
    "text": "Output: Student s2=new Student(); 111 Karan s1.insertRecord(111,\"Karan\"); 222 Aryan s2.insertRecord(222,\"Aryan\"); s1.displayInformation(); s2.displayInformation(); } } [PAGE 17] Java Class and Objects Object gets the memory in heap memory area. The reference variable refers to the object allocated in the heap memory area. Here, s1 and s2 both are reference variables that refer to the objects allocated in memory. [PAGE 18] Java Class and Objects 3) Object and Class Example: Initialization through a constructor A constructor in Java is a special method that is used to initialize objects. The constructor is called when an object of a class is created. It can be used to set initial values for object attributes [PAGE 19] Java Class and Objects Object and Class Example: Employee public class TestEmployee { File: TestEmployee.java public static void main(String[] args) { class Employee{ Employee e1=new Employee(); Employee e2=new Employee(); int id; Employee e3=new Employee(); String name; e1.insert(101,\"ajeet\",45000); float salary; e2.insert(102,\"irfan\",25000); void insert(int i, String n, float s) e3.insert(103,\"nakul\",55000); { e1.display(); Output: id=i; e2.display(); 101 ajeet 45000.0 e3.display(); name=n; } 102 irfan 25000.0 salary=s; } 103 nakul 55000.0 } void display(){System.out.println(id+\" \"+name+\" \"+salary);} } [PAGE 20] Java Class and Objects Object and Class Example: Rectangle File: TestRectangle1.java class TestRectangle1{ public",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_6",
    "text": "static void main(String args[]){ Rectangle r1=new Rectangle(); Rectangle r2=new Rectangle(); class Rectangle{ r1.insert(11,5); int length; r2.insert(3,15); r1.calculateArea(); int width; r2.calculateArea(); void insert(int l, int w){ Output: } length=l; 55 } width=w; 45 } void calculateArea() {System.out.println(length*width);} } [PAGE 21] Java method In general, a method is a way to perform some task. Similarly, the method in Java is a collection of instructions that performs a specific task. It provides the reusability of code. We can also easily modify code using methods. In this section, we will learn what is a method in Java, types of methods, method declaration, and how to call a method in Java. What is a method in Java? A method is a block of code or collection of statements or a set of code grouped together to perform a certain task or operation. It is used to achieve the reusability of code. We write a method once and use it many times. We do not require to write code again and again. It also provides the easy modification and readability of code, just by adding or removing a chunk of code. The method is executed only when we call or invoke it. The most important method",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_7",
    "text": "in Java is the main() method. If you want to read more about the main() method. [PAGE 22] Java method Method Declaration The method declaration provides information about method attributes, such as visibility, return-type, name, and arguments. It has six components that are known as method header, as we have shown in the following figure. [PAGE 23] Java method Method Signature: Every method has a method signature. It is a part of the method declaration. It includes the method name and parameter list. Access Specifier: Access specifier or modifier is the access type of the method. It specifies the visibility of the method. Java provides four types of access specifier: Public: The method is accessible by all classes when we use public specifier in our application. Private: When we use a private access specifier, the method is accessible only in the classes in which it is defined. Protected: When we use protected access specifier, the method is accessible within the same package or subclasses in a different package. Default: When we do not use any access specifier in the method declaration, Java uses default access specifier by default. It is visible only from the same package only. [PAGE 24] Java",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_8",
    "text": "method Return Type: Return type is a data type that the method returns. It may have a primitive data type, object, collection, void, etc. If the method does not return anything, we use void keyword. Method Name: It is a unique name that is used to define the name of a method. It must be corresponding to the functionality of the method. Suppose, if we are creating a method for subtraction of two numbers, the method name must be subtraction(). A method is invoked by its name. Parameter List: It is the list of parameters separated by a comma and enclosed in the pair of parentheses. It contains the data type and variable name. If the method has no parameter, left the parentheses blank. Method Body: It is a part of the method declaration. It contains all the actions to be performed. It is enclosed within the pair of curly braces. [PAGE 25] Java method Naming a Method While defining a method, remember that the method name must be a verb that start with a lowercase letter and combine with Noun and its first letter is a uppercase as like class name. The method has more than two words, the",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_9",
    "text": "first method name followed by adjective noun. For example: Single-word method name: sumData() findArea() Multi-word method name: sumOfData() findAreaOfCircle() It is also possible that a method has the same name as another method name in the same class, it is known as method overloading. [PAGE 26] Java method Types of Method There are two types of methods in Java: Predefined Method User-defined Method Predefined Method In Java, predefined methods are the method that is already defined in the Java class libraries is known as predefined methods. It is also known as the standard library method or built-in method. We can directly use these methods just by calling them in the program at any point. Example: length(), equals(), compareTo(), sqrt(), etc. When we call any of the predefined methods in our program, a series of codes related to the corresponding method runs in the background that is already stored in the library. [PAGE 27] Java method Each and every predefined method is defined inside a class. Such as print() method is defined in the java.io.PrintStream class. It prints the statement that we write inside the method. For example, print(\"Java\"), it prints Java on the console. Let's see an example of the",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_10",
    "text": "predefined method. Maximum.java public class Maximum { public static void main(String[] args) { // using the max() method of Math class Math.max(9,7)); System.out.print(\"The maximum number is: \" + } } Output: The maximum number is: 9 [PAGE 28] Java method User-defined Method The method written by the user or programmer is known as a user-defined method. These methods are modified according to the requirement. How to Create a User-defined Method Let's create a user defined method that checks the number is even or odd. First, we will define the method. //user defined method findEvenOdd(int num) public static void { //method body if(num%2==0) System.out.println(num+\" is even\"); else System.out.println(num+\" is odd\"); } [PAGE 29] Java method How to Call or Invoke a User-defined Method Once we have defined a method, it should be called. The calling of a method in a program is simple. When we call or invoke a user-defined method, the program control transfer to the called method. import java.util.Scanner; public class EvenOdd // file name is EvenOdd.java { public static void main (String args[]) { //creating Scanner class object Scanner scan=new Scanner(System.in); System.out.print(\"Enter the number: \"); //reading value from the user int num=scan.nextInt(); //method calling findEvenOdd(sum); } [PAGE 30]",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_11",
    "text": "Java method Let's combine both snippets of codes in a single program and execute it. EvenOdd.java //user defined method import java.util.Scanner; public static void findEvenOdd(int num) public class EvenOdd { { //method body public static void main (String args[]) if(num%2==0) { System.out.println(num+\" is even\"); else //creating Scanner class object System.out.println(num+\" is odd\"); Scanner scan=new Scanner(System.in); } System.out.print(\"Enter the number: \"); } //reading value from user int num=scan.nextInt(); //method calling findEvenOdd(num); } Output: Enter the number: 12 12 is even [PAGE 31] Java method Addition.java public class Addition { public static void main(String[] args) { int a = 19; //user defined method int b = 5; public static int add(int n1, int n2) //method calling //n1 and n2 are formal parameters int c = add(a, b); //a and b are actual parameters { System.out.println(\"Thientsus;m of a and b is= \" + c); } s=n1+n2; return s; //returning the sum } } Output: The sum of a and b is= 24 [PAGE 32] Java method Static Method A method that has static keyword is known as static method. In other words, a method that belongs to a class rather than an instance of a class is known as a static method. We",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_12",
    "text": "can also create a static method by using the keyword static before the method name. The main advantage of a static method is that we can call it without creating an object. It can access static data members and also change the value of it. It is used to create an instance method. It is invoked by using the class name. The best example of a static method is the main() method. [PAGE 33] Java method Example of static method Display.java public class Display { public static void main(String[] args) { show(); } static void show() { System.out.println(\"It is an example of static method.\"); } } Output: It is an example of a static method. [PAGE 34] What do you understand? [PAGE 35] Constructors In Java, a constructor is a block of codes similar to the method. It is called when an instance of the class is created. At the time of calling constructor, memory for the object is allocated in the memory. It is a special type of method which is used to initialize the object. Every time an object is created using the new() keyword, at least one constructor is called. It calls a default constructor if there",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_13",
    "text": "is no constructor available in the class. In such case, Java compiler provides a default constructor by default. There are two types of constructors in Java: No-argument constructor, and parameterized constructor. Note: It is called constructor because it constructs the values at the time of object creation. It is not necessary to write a constructor for a class. It is because java compiler creates a default constructor if your class doesn't have any. [PAGE 36] Constructors Rules for creating Java constructor There are two rules defined for the constructor. Constructor name must be the same as its class name A Constructor must have no explicit return type A Java constructor cannot be abstract, static, final, and synchronized Note: We can use access modifiers while declaring a constructor. It controls the object creation. In other words, we can have private, protected, public or default constructor in Java. [PAGE 37] Constructors Types of Java constructors There are two types of constructors in Java: 1. Default constructor (no-argument constructor) 2. Parameterized constructor In this example, we are creating the no-arg constructor in the Bike class. It will be invoked at the time of object creation. Example of default constructor //Java Program to create",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_14",
    "text": "and call a default constructor class Bike1{ //creating a default constructor Bike1() { System.out.println(\"Bike is created\"); } //main method Output: public static void main(String args[]){ Bike is created //calling a default constructor Bike1 b=new Bike1(); } } [PAGE 38] Constructors Rule: If there is no constructor in a class, compiler automatically creates a default constructor. What is the purpose of a default constructor? The default constructor is used to provide the default values to the object like 0, null, etc., depending on the type. [PAGE 39] Constructors Example of default constructor that displays the default values //Let us see another example of default constructor //which displays the default values class Student3{ int id; String name; //method to display the value of id and name void display(){System.out.println(id+\" \"+name);} public static void main(String args[]){ //creating objects Student3 s1=new Student3(); Output: Student3 s2=new Student3(); 0 null //displaying values of the object 0 null s1.display(); s2.display(); } } [PAGE 40] Constructors Parameterized Constructor A constructor which has a specific number of parameters is called a parameterized constructor. Why use the parameterized constructor? The parameterized constructor is used to provide different values to distinct objects. However, you can provide the same values also. Example of",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_15",
    "text": "parameterized constructor In this example, we have created the constructor of Student class that have two parameters. We can have any number of parameters in the constructor. [PAGE 41] Constructors //Java Program to demonstrate the use of the parameterized constructor. class Student4{ int id; String name; //creating a parameterized constructor Student4(int i,String n){ id = i; name = n; } Output: //method to display the values void display(){System.out.println(id+\" \"+name);} 111 Karan public static void main(String args[]){ 222 Aryan //creating objects and passing values Student4 s1 = new Student4(111,\"Karan\"); Student4 s2 = new Student4(222,\"Aryan\"); //calling method to display the values of object s1.display(); s2.display(); } } [PAGE 42] // parameterized constructor to initialize the dimensions of a box. class Box { double width; double height; Output: double depth; Volume is 3000.0 Box(double w, double h, double d) { Volume is 162.0 width = w; height = h; depth = d; } double volume() // compute and return volume { return width * height * depth; } } class BoxDemo7 { public static void main(String args[]) { Box mybox1 = new Box(10, 20, 15); Box mybox2 = new Box(3, 6, 9); double vol; vol = mybox1.volume(); // get volume of first box",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_16",
    "text": "System.out.println(\"Volume is \" + vol); vol = mybox2.volume(); // get volume of second box System.out.println(\"Volume is \" + vol); }} [PAGE 45] Stack Operation [PAGE 46] // This class defines an integer stack that can hold 10 values. class Stack { int stck[] = new int[10]; int top; class TestStack { // Initialize top-of-stack public static void main(String args[]) Stack() { { top = -1; Stack mystack1 = new Stack(); } Stack mystack2 = new Stack(); // Push an item onto the stack // push some numbers onto the stack void push(int item) { for(int i=0; i<10; i++) mystack1.push(i); if(top==9) for(int i=10; i<20; i++) mystack2.push(i); System.out.println(\"Stack is full.\"); // pop those numbers off the stack else System.out.println(\"Stack in mystack1:\"); stck[++top] = item;} for(int i=0; i<10; i++) // Pop an item from the stack System.out.println(mystack1.pop()); int pop() { System.out.println(\"Stack in mystack2:\"); if(top < 0) { for(int i=0; i<10; i++) System.out.println(\"Stack underflow.\"); System.out.println(mystack2.pop()); return 0; } }else } return stck[top--]; }} [PAGE 47] Java Constructor Difference between constructor and method in Java Java Constructor Java Method A constructor is used to initialize the A method is used to expose the state of an object. behavior of an object. A constructor must not",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_17",
    "text": "have a return A method must have a return type. type. The constructor is invoked implicitly. The method is invoked explicitly. The Java compiler provides a default The method is not provided by the constructor if you don't have any compiler in any case. constructor in a class. The constructor name must be same The method name may or may not as the class name. be same as the class name. [PAGE 48] Java Constructor Java Copy Constructor There is no copy constructor in Java. However, we can copy the values from one object to another like copy constructor in C++. There are many ways to copy the values of one object into another in Java. They are: By constructor By assigning the values of one object into another By clone() method of Object class In this example, we are going to copy the values of one object into another using Java constructor. [PAGE 49] Java Constructor //Java program to initialize the values from one object to another object. class Student6{ int id; public static void main(String args[]){ String name; Student6 s1 = new Student6(111,\"Karan\"); Student6 s2 = new Student6(s1); //constructor to initialize integer and string s1.display(); Student6(int i,String n){",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  },
  {
    "id": "Unit-2.1 Class_18",
    "text": "s2.display(); id = i; } name = n; } } //constructor to initialize another object Student6(Student6 s){ Output: id = s.id; 111 Karan name =s.name; 111 Karan } void display(){System.out.println(id+\" \"+name);} [PAGE 50] Java Constructor Copying values without constructor We can copy the values of one object into another by assigning the objects values to another object. In this case, there is no need to create the constructor. class Student7{ public static void main(String args[]){ int id; Student7 s1 = new Student7(111,\"Karan\"); String name; Student7 s2 = new Student7(); Student7(int i,String n){ s2.id=s1.id; id = i; s2.name=s1.name; name = n; s1.display(); s2.display(); } } Student7(){} } void display() {System.out.println(id+\" \"+name);} Output: 111 Karan 111 Karan",
    "metadata": {
      "unit": "Unknown",
      "topic": "[SOURCE_TYPE: PDF]",
      "source_file": "Unit-2.1 Class.txt"
    }
  }
]
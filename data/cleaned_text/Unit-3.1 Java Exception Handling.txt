
TOPIC: [SOURCE_TYPE: PDF]

Definition:
[FILE: Unit-3.1 Java Exception Handling.pdf]

[PAGE 1]
Content
1. Exception Handling
2. Exception Classes
3. try and catch
4. throw and throws
5. Multiple catch Exceptions
6. Annotations
[PAGE 2]
1. Exception Handling
[PAGE 3]
Introduction
Exception is an abnormal condition that arises when
executing a program.
In the language that do not support exception handling,
errors must be checked and handled manually, usaually
through the use of error codes.
* Java provides syntactic mechanisms to signal, detect
and handle errors.
* Java ensures a clean separation between the code
executed in the absence of errors and the code to
handle various kinds of errors.
* Java brings run-time error management into object-
oriented programming.
[PAGE 4]
Introduction cont...
An exception is an object that describes an exceptional
condition (error) that has occured when executing a
program.
Exception handling involves:
1. When an error occurs, an object (exception)
representing this error is created and thrown in the
method that caused it.
2. That method may choose to handle the exception
itself or pass it on.
3. Either way, at some point, the exception is caught and
processed.
[PAGE 5]
Introduction cont...
Exception Sources
Exceptions can be:
1. Generated by the Java run-time system
Fundamental errors that violate the rules of the
Java language or the constraints of the Java
execution environment.
Ex: IOException, ClassNotFoundException,
SQLException, RuntimeException, etc.
2. Manually generated by programmer’s code.
This exceptions are typically used to report some
error conditions to the caller of a method.
[PAGE 6]
Need for Exception Handling
Java programs are compiled and executed by JVM (Java Virtual
Machine). Java compiler translate the statements in a program as like
an Interpreter based approach.
Suppose if any unexpected error (Exceptional condition) occurs, the
execution stopped or terminated.
A good programmer understand the statements that may create
unexpected error, then that statement included with exception
handling. Now all the statements in the program will be executed.
[PAGE 7]
Need for Exception Handling cont...
An exception may occur:
* Invalid data as input
* File cannot be found or opened.
* Network connection may be disturbed in the
middle of communications.
* JVM may run out of memory.
[PAGE 8]
Testing of Exception Handling
package gg_test;
class Arithmetic
{
public static void main(String[] args)
{
int a = 0;
int b = 12/a;
System.out.println(+b);
}
}
When executing the class file
Exception in thread "main" java.lang.ArithmeticException: / by zero
at gg_test/gg_test.Arithmetic.main(Arith.java:7)
[PAGE 9]
Points to Remember
Exception:
* Exception is an abnormal condition that arises
at run time.
* Event that disrupts the normal flow of the program.
* It is an object which is thrown at run time.
Exception Handling:
* It is a mechanism to handle runtime errors.
* Normal flow of the application can be maintained.
* It is an object which is thrown at runtime.
* Exception handling done with the exception object.
[PAGE 10]
System Errors
1. Syntax Errors:
Compiler detects the errors, when the rules of the language have not
been followed.
2. Runtime Errors:
When the program is running under an environment that detects an
operation is impossible to carry out.
3. Logic Errors:
When the program does not perform the way it was intended to.
[PAGE 11]
2. Exception Classes
[PAGE 12]
Introduction
Java exception classes are arranged in a hierarchical
manner.
Throwable class is the root class in this hierarchy.
A programmer can import the root class and use the
exception handling technique in their program.
The “import java.lang.Throwable;” statement can provide
to all exceptions and errors.
Throwable class inherited by two subclasses:
1. Exception
2. Error
[PAGE 13]
Exception Types
1. Checked Exceptions (compile / static time):
Compiler detects the errors, when the rules of the language have not been
followed.
Ex: IOException, SQLException.
2. Unchecked Exception (Runtime / Dynamic):
The ignored exceptions at the time of compilation. When the program is
running under an environment that detects an operation is impossible to
carry out.
These includes programming bugs (logic error or improper use of an API).
Ex: ArithmeticException, ArrayIndexOutOfBoundsException,
NullPointerException.
3. Errors:
Errors are not exceptions, but problems may arise beyond the control
of the user or the programmer.
Ex: OutOfMemoryError, VirtualMachineError, AssertionError.
[PAGE 14]
Exception Class Hierarchy
[PAGE 15]
Exception Class Hierarchy cont...
All exceptions are sub-classes of the build-in class “Throwable”.
Throwable contains two immediate sub-classes:
1. Exception – Program should catch exceptional
conditions.
The Exception class includes:
(a) RuntimeException – Defined automatically for user
programs to include: division by
zero, invalid array indexing, etc.
(b) user defined exception classes
2. Error – Indicate the error with the run-time environment, when user
programs are not supposed to catch them.
[PAGE 16]
Exception Handling Keywords
1. try – a block surrounding program statements to
monitor for exception.
2. catch – together with try, catches specific kinds of
exceptions and handles them in some way.
3. finally – specifies any code that absolutely must be
executed whether or not an exception occurs.
4. throw – used to throw a specific exception from the
program
5. throws – specifies which exceptions a given method
can throw.
[PAGE 17]
Exception Handling Methods
Method Description
Returns a detailed message about the exception that has occurred.
public String getMessage()
This message is initialized in the Throwable constructor.
public Throwable getCause() Returns the cause of the exception as represented by a Throwable object.
Returns the name of the class concatenated with the result of
public String toString()
getMessage().
Prints the result of toString() along with the stack trace to System.err, the
public void printStackTrace()
error output stream.
public StackTraceElement []
Returns an array containing each element on the stack trace.
The element at index 0 represents the top of the call stack, and the last
getStackTrace()
element in the array represents the method at the bottom of the call stack.
public Throwable
Fills the stack trace of this Throwable object with the current stack trace,
adding to any previous information in the stack trace.
fillInStackTrace()
[PAGE 18]
3. try and catch
[PAGE 19]
Introduction
try – a block surrounding program statements to
monitor for exception.
Syntax:
try {
// block of code to monitor for errors
// the code you think can raise an exception
}
catch(ExceptionType <exception_object>)
{
// exception handler for ExceptionType
}
finally // optional
{
// block of code to be executed after try block ends.
}
[PAGE 20]
Implementation
A method catches an exception using a combination of try and catch
keywords.
The program code that may generate an exception should be placed
inside the try-catch block.
The program code which is prone to exception is placed in the try
block.
When an error occurs, that exception is handled by catch block
associated with it.
Every try block should be immediately followed either by a catch
block or finally block.
[PAGE 21]
Implementation cont...
A catch statement involves declaring the type of exception that might
be tried to catch.
If an error occurs, the catch block follow the try block is checked.
If the type of exception that occurred is listed in a catch block.
The exception is passed to the catch block similar to an argument
that is passed into a method parameter.
[PAGE 22]
Implementation cont...
package gg_test;
class Arithmetic
{
public static void main(String[] args)
{
int a = 0;
int b = 12/a;
System.out.println(+b);
}
}
When executing the class file
Exception in thread "main" java.lang.ArithmeticException: / by zero
at gg_test/gg_test.Arithmetic.main(Arith.java:7)
[PAGE 23]
Implementation cont...
package gg_test;
class Arithmetic
{
public static void main(String[] args)
{
try {
int a = 0;
int b = 12/a;
// control moves to immediate catch block
System.out.println(+b);
}
catch (ArithmeticException e)
{
System.out.println(“Division by Zero”);
}
// The exception is handled and the execution resumes
int b = 12/a; System.out.println(+b);
}
}
[PAGE 24]
Implementation cont...
The purpose of catch should be to resolve the exception and then continue
as if the error had never happened.
try-catch inside a loop:
catch (ArithmeticException e)
{
import java.util.Random;
System.out.println(“Division by zero”);
a=0; // set a=0 and contine
class HandleError {
}
public static void main(String args[]) {System.out.println(“a=” +a);
int a=0, b=0, c=0; }
Random r = new Random(); }
for(int i=0; i<32000; i++) { }
try {
b=r.nextInt();
c=r.nextInt();
a=12345 / (b/c);
}
[PAGE 25]
Implementation cont...
Output:
Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3
Out of the block
[PAGE 26]
Implementation cont...
class MultiCatch { Java SE 7 and after
public static void main(String args[]) {
try {
int array[] = new int[10]; // Array Index 0 to 9
array[10] = 50 / 0;
}
catch(ArithmeticException e) {
System.out.println(e.getMessage());
}
catch(ArrayIndexOutOfBoundsException b) {
System.out.println(b.getMessage());
}
The associativity of the
} }
assignment operator “=” is
Output:
right to left.
/ by zero
Therefore, ArithmeticException
is thrown first.
[PAGE 27]
Implementation cont...
class MultiCatch {
public static void main(String args[]) {
try {
int array[] = new int[10]; // Array Index 0 to 9
array[10] = 50 / 0;
}
catch(ArithmeticException | ArrayIndexOutOfBoundsException e)
{
System.out.println(e.getMessage());
}
1. Reduce the code duplication
}
2. Increases the efficiency.
}
3. If a catch block handles
Output:
multiple exceptions, the catch
/ by zero
parameter is implicitly final. It
means we cannot assign any
values to catch parameters.
[PAGE 28]
Implementation cont...
class MultiCatch {
public static void main(String args[]) {
try {
int array[] = new int[10]; // Array Index 0 to 9
array[10] = 50 / 0;
}
catch(Exception e)
{
System.out.println(e.getMessage());
}
* If multiple exception in a single
catch block, the rule is generalized
}
to specialized. Then there is a
}
Output:
hierarchy of exception.
/ by zero * We can catch the “base exception”
only instead of catching multiple
specialized exceptions.
[PAGE 29]
Implementation cont...
class MultiCatch {
public static void main(String args[]) {
try {
int array[] = new int[10]; // Array Index 0 to 9
array[10] = 50 / 0;
}
catch(Exception | ArithmeticException | ArrayIndexOutOfBoundsException e)
{
System.out.println(e.getMessage());
}
ArithmeticException and
ArrayIndexOutOfBoundsException
}
are subclasses of Exception class.
}
Output:
MultiCatch.java:7: error: Alternatives in a multi-catch
statement cannot be related by subclassing
[PAGE 30]
4. throw and throws
[PAGE 31]
Introduction
User program may throw an exception explicitly;
throw ThrowableInstance;
ThrowableInstance must be an object of type Throwable or its subclass.
Once an exception is thrown by the above exception statement
1. the flow of control stops immediately.
2. the nearest enclosing “try” statement is inspected if it has a “catch” statement that
matches the type of exception:
a. If one exists, control is transferred to that statement
b. Otherwise, the next enclosing “try” statement is examined.
c. If no enclosing “try” statement has a corresponding “catch” c;ause, the default
exception handler halts the program and prints the stack.
[PAGE 32]
Introduction
Two ways to obtain a Throwable instance:
1. Creating one with the “new” operator
All java built-in exception have at least two constructors:
One without parameters and another with one String parameter.
throw new NullPointerException(“demo”);
2. using a parameter of the “catch” clause
try {
. . .
}
catch(Throwable e)
{
. . .
e
. . .
[PAGE 33]
throw
output:
class ThrowDemo {
Caught inside demoproc.
static void demoproc() {
Recaught: java.lang.NullPointerException: demo
try {
throw new NullPointerException("demo");
} catch(NullPointerException e)
{
System.out.println("Caught inside demoproc.");
throw e; // rethrow the exception
}
}
public static void main(String args[]) {
try { demoproc();
} catch(NullPointerException e)
{ System.out.println("Recaught: " + e); }
} }
[PAGE 34]
throw
The program gets two chances to deal with the same error.
First, main( ) sets up an exception context and then calls
demoproc( ).
The demoproc( ) method then sets up another
exception-handling context and immediately throws a new
instance of NullPointerException, which is caught on the
next line.
The exception is then re-thrown.
[PAGE 35]
throws
A throws clause lists the types of exceptions that a
method might throw.
All other exceptions that a method can throw must be
declared in the throws clause.
If they are not, a compile-time error will result.
Type method-name(parameter-list) throws exception-list
{ // body of method }
Here, exception-list is a comma-separated list of the
exceptions that a method can throw.
[PAGE 36]
throws
// This program contains an error and will not compile.
class ThrowsDemo {
static void throwOne() {
System.out.println("Inside throwOne.");
throw new IllegalAccessException("demo");
}
public static void main(String args[])
{ throwOne();
}
}
[PAGE 37]
throws
// This is now correct
class ThrowsDemo {
static void throwOne() throws IllegalAccessException
{
System.out.println("Inside throwOne.");
throw new IllegalAccessException("demo");
}
public static void main(String args[]) {
try {
Output:
throwOne(); inside throwOne
caught java.lang.IllegalAccessException: demo
}
catch (IllegalAccessException e) {
System.out.println("Caught " + e);
}
}}
[PAGE 38]
User Defined Exception
To create your own exception types to handle situations specific
to your applications.
Define a subclass of Exception, subclasses don’t need to
actually implement anything.
class MyException extends Exception { . . . }
The Exception class does not define any methods of its own.
It inherit those methods provided by Throwable
[PAGE 39]
Throwable class Methods
Throwable fillInStackTrace() - returns a Throwable object that contains a
completed stack trace; the object can be rethrown.
Throwable getCause() - returns the exception that underlines the current
exception. If no underlying exception exists, null is returned.
String getLocalizedMessage() - returns a localized description of the exception.
String getMessage() - returns a description of the exception.
StackTraceElement[] getStackTrace() - returns an array that contains the stack
trace; the method at the top is the last one called before exception.
[PAGE 40]
Throwable class Methods
Throwable initCause(Throwable causeExc) – associates causeExc with the
invoking exception as its cause, returns the exception reference.
void printStackTrace() - displays the stack trace
void printStackTrace(PrintStream stream) – sends the stack trace to the
specified stream.
void printStackTrace(PrintWriter stream)
void setStackTrace(StackTraceElement elements[ ]) - sets the stack trace to the
elements passed in elements; for specialized applications only.
String toString() - returns a String object containing a description of the
exception; called by print() when displaying a Throwable object.
[PAGE 41]
Creating User Defined Exception
In order to create custom exception, we need to extend Exception class that
belongs to java.lang package.
Consider the following example, where we create a custom exception named
WrongFileNameException:
public class WrongFileNameException extends Exception {
public WrongFileNameException(String errorMessage) {
super(errorMessage);
}
}
Example 1:
Let's see a simple example of Java custom exception. In the following code,
constructor of InvalidAgeException takes a string as an argument. This string is
passed to constructor of parent class Exception using the super() method. Also
the constructor of Exception class can be called without using a parameter and
calling super() method is not mandatory.
[PAGE 42]
Creating User Defined Exception
else {
// class representing custom exception
System.out.println("welcometovote");
class InvalidAgeException extends Exception
}
{
}
public InvalidAgeException (String str)

{ • //mainmethod
// calling the constructor of parent Exception • public static void main(Stringargs[])
super(str); • {
try
} }
{

//callingthemethod
// class that uses custom exception InvalidAgeException
validate(13);
public class TestCustomException1
}
{
catch (InvalidAgeExceptionex)

{
// method to check the age • System.out.println("Caughttheexception");
static void validate (int age) throws InvalidAgeExcep•tion{
if(age < 18){ • //printingthemessagefromInvalidAgeExceptionobject
System.out.println("Exceptionoccured:"+ex);

}
// throw an object of user defined exception

throw new InvalidAgeException("age is not valid to vote");
System.out.println("restofthecode...");
}
}
}
[PAGE 43]
Creating User Defined Exception
class ExceptionDemo
{
static void compute (int a) throws MyException{
System.out.println(“Called compute(“+a+”)”);

if(a > 10) throw new MyException(a);
System.out.println(“Normal exit”);
}
}
The static compute method throws the MyException exception
whenever its ‘a’ argument is greater than 10.
[PAGE 44]
Creating User Defined Exception
The main method calls compute with two arguments within a try
block that catches the MyException exception.
public static void main(String args[]) {
try {
compute(1);
compute(20);
}
catch(MyException e) {
System.out.println(“caught “ +e);
}
}// end of main
[PAGE 45]
Chained Exceptions
The chained exception allows to associate with a given
exception another exception that describes its cause.
Throwable class includes two constructors to handle
chained exceptions:
1. Throwable (Throwable causeExc)
2. Throwable (String msg, Throwable causeExc)
Both constructor create an exception with “causeExc”
being its underlying reason and optional “msg”
providing the textual description.
[PAGE 46]
Chained Exceptions
Throwable class also include two methods to handle chained
exceptions:
1. Throwable getCause() - returns an exception that is the
cause of the current exception, or null if there is no
underlying exception.
2. Throwable initCause(Throwable causeExc) – associates
“causeExc” with the invoking exception and returns a
reference to the exception.
a. InitCause - allows to associate a cause with an existing
exception.
b. The cause exception can be set only once.
c. If the cause exception was set by a constructor, it is
not possible to set it again with initCause.
[PAGE 47]
Chained Exceptions - Example-1
class ChainExcDemo {
/* The demoprocess method creates a new
“NullPointerException” exception “e”, associates
“ArithmeticException” as its cause, then throws “e”.
*/
static void demoprocess() {
NullPointerException e = new NullPointerException(“top layer”);
e.initCause(new ArithmeticException(“cause”));
throw e;
}
[PAGE 48]
Chained Exceptions - Example-2
The “main” method calls the method “demoprocess” within the “try”
block that catches “NullPointerException”, then displays the exception
and its cause.
public static void main(String args[]) {
try {
demoprocess();
}
catch(NullPointerException e) {
System.out.println(“Caught: “ +e);
System.out.println(“Cause: “ +e.getCause());
}
} // end of main
} // end of class
A cause exception may iteself have a cause. In fact, the cause-chain
of exception may be arbitrarily long
[PAGE 49]
Exception Handling - Exercise-1
Step-1: Create exception classes “Even” and “Odd”.
Step-2: Generate numbers within an endless loop. Print the generated
numbers.
Step-3: If the number is even, throw the Even exception with the
message “The number thrown an even number” along with the
number.
Step-4: If the number is odd, throw the Odd exception with the message
“The number thrown an odd number” along with the number.
Step-5: Catch the Even exception within the endless loop and print the
message.
Step-6: Catch the Odd exception outside of the loop and print the
message.
[PAGE 50]
Annotations
[PAGE 51]
Introduction
Annotations, a form of metadata, provide data about a program that is not part of
the program itself.
Annotations have no direct effect on the operation of the code they annotate.
Annotations provide additional information about the program to the compiler,
and do not affect the execution of the compiled program.
Annotations start with @ symbol.
Syntax: @AnnotationName
[PAGE 52]
Usage
Annotations have a number of uses.
Information for the Compiler: Annotations can be used by the compiler to detect
errors or suppress warnings.
Compile-time and Deployment-time Processing: Software tools can process
annotation information to generate code, XML files, and so forth.
Runtime Processing: Some annotations are available to be examined at runtime.
Note:
Find the annotation types are available in the Java Platform, Standard Edition
(Java SE API),
[PAGE 53]
Types of Annotation
Annotations enable Java code to be analyzed better and provide even stronger
type checks.
1. Predefined Annotations 2. Meta-annotations
a. @Deprecated a. @Retention
b. @Override b. @Documented
c. @SuppressWarnings c. @Target
d. @SafeVarargs d. @Inherited
e. @FunctionalInterface e. @Repeatable
[PAGE 54]
Annotation - Example
Java annotations can be placed above class, method, interface, fields, and other
element declarations.
@Override - When a method overriding. Not mandatory, if use it, the compiler
gives an error if something is wrong while overriding.
Parameter type
@SuppressWarnings
class WordProcess {
@SuppressWarnings(“unchecked”)
Static void wordsList() {
ArrayList wordList = new ArrayList<>();
// This cause an unchecked warning
WordList.add(“Program”);
System.out.println(Word List =>” +wordList);
}